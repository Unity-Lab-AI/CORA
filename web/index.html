<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C.O.R.A - Cognitive Operations & Reasoning Assistant</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="C.O.R.A - A Windows 11 AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, image generation, and live system monitoring. Built by Unity AI Lab.">
    <meta name="keywords" content="CORA, AI Assistant, Ollama, Voice Assistant, Unity AI Lab, Windows 11, Personal Assistant">
    <meta name="author" content="Unity AI Lab - Hackall360, Sponge, GFourteen">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://www.unityailab.com/CORA/">
    <meta property="og:title" content="C.O.R.A - Cognitive Operations & Reasoning Assistant">
    <meta property="og:description" content="AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, image generation, and live system monitoring. Open source by Unity AI Lab.">
    <meta property="og:image" content="http://www.unityailab.com/CORA/images/social-preview.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Unity AI Lab">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="http://www.unityailab.com/CORA/">
    <meta name="twitter:title" content="C.O.R.A - Cognitive Operations & Reasoning Assistant">
    <meta name="twitter:description" content="AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, and image generation. Open source by Unity AI Lab.">
    <meta name="twitter:image" content="http://www.unityailab.com/CORA/images/social-preview.png">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="images/social-preview.png">

    <style>
        :root {
            --bg-main: #0a0a0a;
            --bg-panel: #12121a;
            --bg-darker: #08080c;
            --border-color: #302050;
            --text-main: #e0e0e0;
            --text-dim: #888;
            --accent-magenta: #ff00ff;
            --accent-cyan: #00ffff;
            --ok-color: #00ff88;
            --warn-color: #ffaa00;
            --fail-color: #ff4444;
            --pending-color: #666;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: var(--bg-main);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
        }

        /* Two Column Layout - matches desktop boot_display.py */
        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
            gap: 0;
            transition: grid-template-columns 0.3s ease;
        }

        /* Fullscreen mode - console only */
        .container.fullscreen-console {
            grid-template-columns: 0 1fr;
        }
        .container.fullscreen-console .left-panel {
            display: none;
        }

        /* Fullscreen mode - status only */
        .container.fullscreen-status {
            grid-template-columns: 1fr 0;
        }
        .container.fullscreen-status .right-panel {
            display: none;
        }

        /* Toggle button */
        .toggle-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
        }
        .toggle-btn:hover {
            background: var(--accent-magenta);
            color: #000;
        }

        /* Left Panel */
        .left-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #1a0020 0%, #0d0015 100%);
            border-bottom: 2px solid var(--accent-magenta);
            padding: 15px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            color: var(--accent-magenta);
            text-shadow: 0 0 15px var(--accent-magenta);
            letter-spacing: 8px;
        }

        .header .subtitle {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 5px;
        }

        .header .version {
            font-size: 11px;
            color: var(--accent-cyan);
            margin-top: 3px;
        }

        /* Waveform - EXACT match to boot_display.py */
        .waveform-container {
            background: #0a0a0a;
            border: 1px solid #302050;
            margin: 10px;
            border-radius: 4px;
            position: relative;
        }

        .waveform-label {
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 9px;
            color: #666;
            z-index: 1;
        }

        #waveformCanvas {
            width: 100%;
            height: 100px;
            display: block;
        }

        /* Speech Text - EXACT like desktop boot_display.py */
        .speech-container {
            background: linear-gradient(180deg, #1a0020 0%, #0d0010 100%);
            border-bottom: 2px solid var(--accent-magenta);
            padding: 15px;
            min-height: 80px;
        }

        .speech-label {
            font-size: 10px;
            color: var(--accent-cyan);
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        #speechText {
            font-size: 14px;
            color: var(--accent-magenta);
            font-style: italic;
            line-height: 1.5;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
            min-height: 42px;
        }

        .tts-notice {
            font-size: 9px;
            color: #555;
            margin-top: 8px;
            font-style: normal;
        }

        .tts-notice a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        /* Progress Bar */
        .progress-container {
            padding: 10px 15px;
            background: var(--bg-darker);
            border-bottom: 1px solid var(--border-color);
        }

        .progress-bar {
            height: 6px;
            background: #1a1a2a;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-magenta), var(--accent-cyan));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 5px;
            text-align: center;
        }

        /* Phases */
        .phases-container {
            padding: 10px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            max-height: 260px;
            overflow-y: auto;
        }

        .phases-header {
            font-size: 10px;
            color: var(--accent-cyan);
            text-align: center;
            margin-bottom: 8px;
        }

        .phases-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .phase-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            padding: 3px 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
        }

        .phase-indicator {
            font-size: 10px;
            width: 14px;
            text-align: center;
        }

        .phase-indicator.pending { color: var(--pending-color); }
        .phase-indicator.running { color: var(--accent-magenta); animation: pulse 1s infinite; }
        .phase-indicator.ok { color: var(--ok-color); }
        .phase-indicator.warn { color: var(--warn-color); }
        .phase-indicator.fail { color: var(--fail-color); }

        @keyframes pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 5px var(--accent-magenta); }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stats-section {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .stats-panel {
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .stats-header {
            font-size: 10px;
            color: var(--accent-cyan);
            text-align: center;
            margin-bottom: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }

        .stat-label { color: var(--text-dim); }
        .stat-value { color: var(--ok-color); font-weight: bold; }
        .stat-value.warn { color: var(--warn-color); }
        .stat-value.na { color: var(--text-dim); font-weight: normal; }

        .web-notice {
            background: #1a1020;
            border: 1px solid #402050;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
            text-align: center;
        }

        .web-notice-title {
            color: var(--warn-color);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .web-notice a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        /* Right Panel - Log */
        .right-panel {
            background: var(--bg-main);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .log-header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            padding: 10px 15px;
            font-size: 12px;
            color: var(--accent-cyan);
        }

        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-line { margin-bottom: 2px; }
        .log-phase { color: var(--accent-magenta); font-weight: bold; margin-top: 10px; }
        .log-ok { color: var(--ok-color); }
        .log-warn { color: var(--warn-color); }
        .log-fail { color: var(--fail-color); }
        .log-info { color: var(--text-dim); }
        .log-system { color: var(--accent-cyan); }
        .log-cora { color: #ff69b4; font-weight: bold; }  /* Hot pink for CORA speech */

        /* Chat */
        .chat-section {
            display: none;
            border-top: 1px solid var(--border-color);
            padding: 15px;
            background: var(--bg-panel);
        }

        .chat-section.visible { display: block; }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        #chatInput {
            flex: 1;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            color: var(--text-main);
            font-family: inherit;
            font-size: 13px;
        }

        #chatInput:focus {
            outline: none;
            border-color: var(--accent-magenta);
        }

        #sendBtn {
            background: linear-gradient(135deg, var(--accent-magenta), #aa00aa);
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.visible { display: flex; }

        .modal {
            background: var(--bg-panel);
            border: 2px solid var(--accent-magenta);
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            color: var(--accent-magenta);
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-field {
            margin-bottom: 20px;
        }

        .modal-field label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-main);
        }

        .modal-field input {
            width: 100%;
            padding: 10px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-main);
            font-family: inherit;
        }

        .modal-field a {
            color: var(--accent-cyan);
            font-size: 12px;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-magenta);
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }

        .gate-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 999;
            align-items: center;
            justify-content: center;
        }

        .gate-overlay.visible { display: flex; }

        .gate-box {
            background: #1a0000;
            border: 2px solid var(--fail-color);
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }

        .gate-box h2 {
            color: var(--fail-color);
            margin-bottom: 15px;
        }

        .gate-box pre {
            background: #0a0a0a;
            padding: 15px;
            border-radius: 4px;
            text-align: left;
            margin: 15px 0;
            color: var(--accent-cyan);
        }

        .gate-box button {
            padding: 12px 30px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 4px;
            color: black;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <!-- Ollama Gate -->
    <div class="gate-overlay" id="gateOverlay">
        <div class="gate-box">
            <h2>[ BLOCKED ]</h2>
            <p>Ollama is not running</p>
            <pre>ollama serve</pre>
            <p style="color: var(--text-dim); font-size: 12px;">Run this in your terminal, then click Retry</p>
            <button onclick="retryOllama()">Retry Connection</button>
        </div>
    </div>

    <!-- API Key Modal -->
    <div class="modal-overlay" id="apiModal">
        <div class="modal">
            <h2>API Configuration</h2>
            <div class="modal-field">
                <label>Pollinations API Key (optional)</label>
                <input type="password" id="pollinationsKey" placeholder="pk_...">
                <a href="https://pollinations.ai" target="_blank">Get key at pollinations.ai</a>
            </div>
            <div class="modal-field">
                <label>GitHub Token (optional)</label>
                <input type="password" id="githubToken" placeholder="ghp_...">
                <a href="https://github.com/settings/tokens" target="_blank">Generate at github.com/settings/tokens</a>
            </div>
            <div class="modal-field">
                <label>Weather API Key (optional)</label>
                <input type="password" id="weatherKey" placeholder="Your OpenWeatherMap key">
                <a href="https://openweathermap.org/api" target="_blank">Get free key at openweathermap.org</a>
            </div>
            <button class="modal-btn" onclick="saveApiKeys()">Save & Continue</button>
            <button class="modal-btn" style="background: #333; margin-top: 10px;" onclick="skipApiKeys()">Skip (Limited Features)</button>
        </div>
    </div>

    <!-- Toggle Buttons -->
    <div style="position: fixed; top: 10px; right: 10px; z-index: 100; display: flex; gap: 8px;">
        <button class="toggle-btn" onclick="openPopupConsole()">[ POP OUT CONSOLE ]</button>
        <button class="toggle-btn" id="toggleBtn" onclick="toggleView()">[ SPLIT VIEW ]</button>
    </div>

    <!-- Main Container -->
    <div class="container" id="mainContainer">
        <div class="left-panel">
            <div class="header">
                <h1>C.O.R.A</h1>
                <div class="subtitle">Cognitive Operations & Reasoning Assistant</div>
                <div class="version">v2.4.0 - Unity AI Lab</div>
            </div>

            <div class="waveform-container">
                <div class="waveform-label">▶ VOICE SYNTHESIS</div>
                <canvas id="waveformCanvas"></canvas>
            </div>

            <div class="speech-container">
                <div class="speech-label">▶ CORA SPEAKING</div>
                <div id="speechText">"Initializing..."</div>
                <div class="tts-notice" id="ttsNotice">Loading Kokoro neural voice (af_bella)...</div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Booting...</div>
            </div>

            <div class="phases-container">
                <div class="phases-header">── BOOT PHASES ──</div>
                <div class="phases-grid" id="phasesSection"></div>
            </div>

            <div class="stats-section">
                <div class="stats-panel">
                    <div class="stats-header">── LIVE SYSTEM STATS ──</div>
                    <div class="stats-grid">
                        <div class="stat-item"><span class="stat-label">CPU:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">MEM:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">DISK:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">GPU:</span><span class="stat-value na">N/A</span></div>
                        <div class="stat-item"><span class="stat-label">VRAM:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">NET:</span><span class="stat-value" id="statNet">--</span></div>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stats-header">── SERVICE STATUS ──</div>
                    <div class="stats-grid">
                        <div class="stat-item"><span class="stat-label">Ollama:</span><span class="stat-value" id="statOllama">--</span></div>
                        <div class="stat-item"><span class="stat-label">Pollinations:</span><span class="stat-value" id="statPollinations">--</span></div>
                        <div class="stat-item"><span class="stat-label">Weather:</span><span class="stat-value" id="statWeather">--</span></div>
                        <div class="stat-item"><span class="stat-label">Boot:</span><span class="stat-value" id="statBootTime">--</span></div>
                    </div>
                </div>

                <div class="web-notice">
                    <div class="web-notice-title">WEB VERSION</div>
                    <div>Full C.O.R.A running in your browser!<br>
                    <a href="https://github.com/Unity-Lab-AI/CORA.git" target="_blank">Get source on GitHub</a></div>
                </div>
            </div>

            <div class="chat-section" id="chatSection">
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Talk to CORA...">
                    <button id="sendBtn" onclick="sendChat()">Send</button>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="log-header">[ BOOT CONSOLE ]</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>

    <script>
        // ============================================================
        // C.O.R.A Web Interface - Full Boot Sequence with TTS
        // Matches desktop boot_sequence.py exactly
        // ============================================================

        // EXACT match to desktop boot_sequence.py phases (19 total)
        const PHASES = [
            { id: 'waveform', name: '0.8 Waveform Init', status: 'pending' },
            { id: 'about', name: '0.9 About CORA', status: 'pending' },
            { id: 'voice', name: '1.0 Voice Synthesis', status: 'pending' },
            { id: 'ai_engine', name: '2.0 AI Engine', status: 'pending' },
            { id: 'ai_models', name: '2.1 AI Models', status: 'pending' },
            { id: 'hardware', name: '3.0 Hardware Check', status: 'pending' },
            { id: 'camera', name: '3.1 Camera Feed', status: 'pending' },
            { id: 'tools', name: '4.0 Core Tools', status: 'pending' },
            { id: 'code_import', name: '4.1 Code Import', status: 'pending' },
            { id: 'youtube', name: '4.2 YouTube Test', status: 'pending' },
            { id: 'modals', name: '4.3 Modal Windows', status: 'pending' },
            { id: 'browser', name: '4.4 Web Browser', status: 'pending' },
            { id: 'voice_sys', name: '5.0 Voice Systems', status: 'pending' },
            { id: 'external', name: '6.0 External APIs', status: 'pending' },
            { id: 'audio', name: '6.1 Audio Test', status: 'pending' },
            { id: 'news', name: '7.0 News Headlines', status: 'pending' },
            { id: 'vision', name: '8.0 Vision Test', status: 'pending' },
            { id: 'imagegen', name: '9.0 Image Gen', status: 'pending' },
            { id: 'final', name: '10.0 Final Check', status: 'pending' }
        ];

        let bootStartTime = null;
        let waveformActive = false;
        let waveformCtx = null;
        let animationId = null;

        let pollinationsKey = localStorage.getItem('cora_pollinations_key') || '';
        let githubToken = localStorage.getItem('cora_github_key') || '';
        let weatherKey = localStorage.getItem('cora_weather_key') || '';

        // ============================================================
        // KOKORO TTS - Neural voice (same as desktop af_bella)
        // Falls back to Web Speech API if Kokoro fails
        // ============================================================

        let kokoroWorker = null;
        let kokoroReady = false;
        let kokoroLoading = false;
        let audioContext = null;
        let pendingCallbacks = {};
        let messageId = 0;
        let useFallbackTTS = false;

        async function initKokoro(progressCallback) {
            if (kokoroReady) return true;
            if (kokoroLoading) return false;

            kokoroLoading = true;

            try {
                // Create audio context (must happen on user interaction for some browsers)
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Create web worker
                kokoroWorker = new Worker('kokoro-worker.js', { type: 'module' });

                return new Promise((resolve) => {
                    const initId = ++messageId;

                    kokoroWorker.onmessage = (e) => {
                        const { type, id, data, error } = e.data;

                        if (type === 'progress' && id === initId) {
                            if (progressCallback) progressCallback(data.message, data.progress);
                        }
                        else if (type === 'initComplete' && id === initId) {
                            kokoroReady = true;
                            kokoroLoading = false;
                            resolve(true);
                        }
                        else if (type === 'error' && id === initId) {
                            console.error('Kokoro init error:', error);
                            kokoroLoading = false;
                            resolve(false);
                        }
                        else if (type === 'audioReady') {
                            handleAudioReady(id, data);
                        }
                        else if (type === 'generating') {
                            // Audio is being generated, keep waveform active
                        }
                    };

                    kokoroWorker.postMessage({ type: 'init', id: initId, data: {} });
                });

            } catch (e) {
                console.error('Failed to init Kokoro:', e);
                kokoroLoading = false;
                return false;
            }
        }

        function handleAudioReady(id, data) {
            if (!pendingCallbacks[id]) return;

            const { resolve, startTime } = pendingCallbacks[id];
            delete pendingCallbacks[id];

            try {
                // Convert ArrayBuffer back to Float32Array
                const float32Audio = new Float32Array(data.audio);
                const sampleRate = data.sampleRate || 24000;

                // Feed audio samples to waveform for visualization
                // Downsample to ~100 samples for waveform display
                const step = Math.max(1, Math.floor(float32Audio.length / 100));
                const waveformSamples = [];
                for (let i = 0; i < float32Audio.length; i += step) {
                    waveformSamples.push(float32Audio[i]);
                }
                feedAudioChunk(waveformSamples);

                // Create audio buffer and play it
                const audioBuffer = audioContext.createBuffer(1, float32Audio.length, sampleRate);
                audioBuffer.copyToChannel(float32Audio, 0);

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                // Create analyser to feed real-time audio to waveform
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                const dataArray = new Float32Array(analyser.frequencyBinCount);

                // Update waveform while playing
                let animFrame;
                const updateWaveform = () => {
                    analyser.getFloatTimeDomainData(dataArray);
                    feedAudioChunk(Array.from(dataArray));
                    if (audio_is_active) {
                        animFrame = requestAnimationFrame(updateWaveform);
                    }
                };

                source.onended = () => {
                    cancelAnimationFrame(animFrame);
                    stopWaveform();
                    resolve();
                };

                startWaveform();
                source.start();
                updateWaveform();

            } catch (e) {
                console.error('Audio playback error:', e);
                stopWaveform();
                resolve();
            }
        }

        function speak(text, callback) {
            // Show speech text with quotes like desktop boot_display.py
            document.getElementById('speechText').textContent = `"${text}"`;

            // Log CORA speech in hot pink to stand out
            log(`CORA: "${text}"`, 'cora');

            if (kokoroReady && !useFallbackTTS) {
                // Use Kokoro neural TTS
                const id = ++messageId;
                pendingCallbacks[id] = {
                    resolve: callback || (() => {}),
                    startTime: Date.now()
                };

                startWaveform();
                kokoroWorker.postMessage({
                    type: 'generate',
                    id,
                    data: { text, voice: 'af_bella', speed: 1.0 }
                });
            } else {
                // Fallback to Web Speech API
                if ('speechSynthesis' in window) {
                    const synth = window.speechSynthesis;
                    synth.cancel();

                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.0;
                    utterance.pitch = 1.1;

                    const voices = synth.getVoices();
                    const femaleVoice = voices.find(v =>
                        v.name.includes('Zira') || v.name.includes('Samantha') ||
                        v.name.toLowerCase().includes('female')
                    ) || voices[0];
                    if (femaleVoice) utterance.voice = femaleVoice;

                    utterance.onstart = () => startWaveform();
                    utterance.onend = () => { stopWaveform(); if (callback) callback(); };
                    utterance.onerror = () => { stopWaveform(); if (callback) callback(); };

                    synth.speak(utterance);
                } else {
                    if (callback) setTimeout(callback, 100);
                }
            }
        }

        function speakAndWait(text) {
            return new Promise(resolve => speak(text, resolve));
        }

        // ============================================================
        // WAVEFORM - EXACT 1:1 PORT FROM boot_display.py AudioWaveform
        // Lines 127-384 of boot_display.py
        // THIS RUNS FOREVER - NEVER STOPS
        // ============================================================

        // EXACT values from boot_display.py lines 140-146
        const NUM_POINTS = 100;  // self.num_points = 100
        let wave_points = new Array(NUM_POINTS).fill(0.0);  // self.wave_points
        let sample_buffer = new Array(NUM_POINTS).fill(0.0);  // self.sample_buffer

        // Audio state - like _audio_buffer_singleton in desktop
        let audio_chunk = null;  // Current audio samples
        let audio_chunk_time = null;  // When chunk was received
        let audio_is_active = false;  // Is TTS currently speaking

        function initWaveform() {
            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            waveformCtx = canvas.getContext('2d');
            waveformCtx.scale(2, 2);

            // Start animation - RUNS FOREVER, NEVER STOPS (line 212)
            _animate();
        }

        // These just set the audio state - animation NEVER stops
        function startWaveform() {
            audio_is_active = true;
            audio_chunk_time = Date.now();
        }

        function stopWaveform() {
            audio_is_active = false;
        }

        // Feed actual audio samples to waveform (like _audio_buffer_singleton)
        function feedAudioChunk(samples) {
            audio_chunk = samples;
            audio_chunk_time = Date.now();
        }

        function _animate() {
            // EXACT port of boot_display.py _animate() lines 205-322
            // "This runs FOREVER once started - never stops."

            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            // Check for audio - like lines 219-236
            let has_audio = false;
            let chunk = null;

            if (audio_chunk_time !== null) {
                const time_since_chunk = Date.now() - audio_chunk_time;
                // Accept chunks up to 300ms old (line 231)
                if (audio_chunk !== null && time_since_chunk < 300 && audio_is_active) {
                    has_audio = true;
                    chunk = audio_chunk;
                }
            }

            if (has_audio && chunk !== null) {
                // Process audio chunk - lines 240-305
                const chunk_len = chunk.length;
                const samples_to_add = Math.min(20, Math.floor(NUM_POINTS / 5));  // line 254

                if (chunk_len >= samples_to_add) {
                    // Downsample - line 258-259
                    const new_samples = [];
                    for (let i = 0; i < samples_to_add; i++) {
                        const idx = Math.floor(i * chunk_len / samples_to_add);
                        new_samples.push(chunk[idx]);
                    }

                    // Find peak for adaptive scaling - lines 263-270
                    let chunk_peak = 0;
                    for (let i = 0; i < chunk.length; i++) {
                        chunk_peak = Math.max(chunk_peak, Math.abs(chunk[i]));
                    }
                    let scale_factor = 20.0;
                    if (chunk_peak > 0.001) {
                        scale_factor = Math.min(0.95 / chunk_peak, 40.0);
                    }

                    // Scale and clamp - lines 270-273
                    for (let i = 0; i < new_samples.length; i++) {
                        new_samples[i] = Math.max(-1.0, Math.min(1.0, new_samples[i] * scale_factor));
                    }

                    // Shift buffer left, add new on right - line 276
                    sample_buffer = sample_buffer.slice(samples_to_add).concat(new_samples);
                }

                // Smooth transition - lines 302-305
                for (let i = 0; i < NUM_POINTS; i++) {
                    wave_points[i] = wave_points[i] * 0.3 + sample_buffer[i] * 0.7;
                }

            } else {
                // No audio - DECAY toward zero (lines 312-316)
                // Desktop behavior: NO fake waves, only real audio or decay
                const decay = 0.92;
                for (let i = 0; i < NUM_POINTS; i++) {
                    wave_points[i] *= decay;
                    sample_buffer[i] *= decay;
                }
            }

            // Draw the wave - line 319
            _draw_wave(width, height);

            // Schedule next frame - 25ms = ~40 FPS - line 322
            setTimeout(() => requestAnimationFrame(_animate), 25);
        }

        function _draw_wave(width, height) {
            // Symmetric waveform - expands OUT from center, collapses TO center at silence
            const ctx = waveformCtx;
            const center_y = height / 2;
            const max_amp = (height / 2) - 5;

            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Center reference line (dim)
            ctx.strokeStyle = '#201030';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, center_y);
            ctx.lineTo(width, center_y);
            ctx.stroke();

            // Build coordinates for top and bottom curves
            // Amplitude expands symmetrically from center
            const step = width / (NUM_POINTS - 1);
            const topCoords = [];
            const bottomCoords = [];

            for (let i = 0; i < NUM_POINTS; i++) {
                const x = i * step;
                const amp = Math.abs(wave_points[i]) * max_amp;
                topCoords.push([x, center_y - amp]);      // Above center
                bottomCoords.push([x, center_y + amp]);   // Below center (mirror)
            }

            if (topCoords.length >= 4) {
                // 4 glow layers
                const layers = [
                    { color: '#400060', width: 8 },   // Outer glow
                    { color: '#8000a0', width: 5 },   // Mid glow
                    { color: '#ff40ff', width: 3 },   // Main wave
                    { color: '#ffc0ff', width: 1 }    // Bright core
                ];

                // Draw each layer as a closed shape (top curve + bottom curve mirrored)
                layers.forEach(layer => {
                    ctx.strokeStyle = layer.color;
                    ctx.lineWidth = layer.width;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Draw top curve (above center)
                    ctx.beginPath();
                    ctx.moveTo(topCoords[0][0], topCoords[0][1]);
                    for (let i = 1; i < topCoords.length - 1; i++) {
                        const xc = (topCoords[i][0] + topCoords[i + 1][0]) / 2;
                        const yc = (topCoords[i][1] + topCoords[i + 1][1]) / 2;
                        ctx.quadraticCurveTo(topCoords[i][0], topCoords[i][1], xc, yc);
                    }
                    ctx.lineTo(topCoords[topCoords.length - 1][0], topCoords[topCoords.length - 1][1]);
                    ctx.stroke();

                    // Draw bottom curve (below center - mirror)
                    ctx.beginPath();
                    ctx.moveTo(bottomCoords[0][0], bottomCoords[0][1]);
                    for (let i = 1; i < bottomCoords.length - 1; i++) {
                        const xc = (bottomCoords[i][0] + bottomCoords[i + 1][0]) / 2;
                        const yc = (bottomCoords[i][1] + bottomCoords[i + 1][1]) / 2;
                        ctx.quadraticCurveTo(bottomCoords[i][0], bottomCoords[i][1], xc, yc);
                    }
                    ctx.lineTo(bottomCoords[bottomCoords.length - 1][0], bottomCoords[bottomCoords.length - 1][1]);
                    ctx.stroke();
                });
            }
        }

        // ============================================================
        // Logging & Phases
        // ============================================================

        function log(text, type = 'info') {
            const container = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            const line = document.createElement('div');
            line.className = `log-line log-${type}`;

            if (type === 'phase') {
                line.style.marginTop = '10px';
                line.textContent = `[${timestamp}] ═══════════════ ${text} ═══════════════`;
            } else {
                const prefix = type === 'ok' ? '✓' : type === 'warn' ? '⚠' : type === 'fail' ? '✗' : '';
                line.textContent = `[${timestamp}] ${prefix ? prefix + ' ' : ''}${text}`;
            }

            container.appendChild(line);
            container.scrollTop = container.scrollHeight;
        }

        function renderPhases() {
            const container = document.getElementById('phasesSection');
            container.innerHTML = '';
            PHASES.forEach(phase => {
                const item = document.createElement('div');
                item.className = 'phase-item';
                let indicator = '○';
                if (phase.status === 'running') indicator = '◐';
                else if (['ok', 'warn', 'fail'].includes(phase.status)) indicator = '●';
                item.innerHTML = `<span class="phase-indicator ${phase.status}">${indicator}</span><span>${phase.name}</span>`;
                container.appendChild(item);
            });
        }

        function setPhase(id, status) {
            const phase = PHASES.find(p => p.id === id);
            if (phase) { phase.status = status; renderPhases(); }
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        // ============================================================
        // API Checks
        // ============================================================

        async function checkOllama() {
            try {
                const r = await fetch('http://localhost:11434/api/tags', { method: 'GET' });
                return r.ok;
            } catch { return false; }
        }

        async function getOllamaModels() {
            try {
                const r = await fetch('http://localhost:11434/api/tags');
                const d = await r.json();
                return d.models || [];
            } catch { return []; }
        }

        async function checkPollinations() {
            try {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve(true);
                    img.onerror = () => resolve(false);
                    setTimeout(() => resolve(false), 5000);
                    img.src = 'https://image.pollinations.ai/prompt/test?width=64&height=64&nologo=true';
                });
            } catch { return false; }
        }

        // Store location coords for reuse
        let cachedCoords = null;

        async function requestLocationPermission() {
            // Request location with generous timeout
            return new Promise((resolve) => {
                log('Requesting location permission...', 'info');
                log('Please click "Allow" when browser asks for location', 'system');

                // Try up to 2 times
                let attempts = 0;
                const maxAttempts = 2;

                function tryGetLocation() {
                    attempts++;
                    navigator.geolocation.getCurrentPosition(
                        (pos) => {
                            cachedCoords = pos.coords;
                            log(`Location acquired on attempt ${attempts}`, 'ok');
                            resolve(pos.coords);
                        },
                        (err) => {
                            if (err.code === 1) {
                                log('Location permission denied by user', 'warn');
                                resolve(null);  // User denied, don't retry
                            } else if (err.code === 2) {
                                log('Location unavailable', 'warn');
                                resolve(null);
                            } else if (err.code === 3) {
                                if (attempts < maxAttempts) {
                                    log(`Location timed out, retrying (${attempts}/${maxAttempts})...`, 'warn');
                                    setTimeout(tryGetLocation, 1000);
                                } else {
                                    log('Location request timed out after retries', 'warn');
                                    resolve(null);
                                }
                            } else {
                                resolve(null);
                            }
                        },
                        {
                            timeout: 60000,           // 60 sec timeout
                            enableHighAccuracy: false,
                            maximumAge: 300000        // Accept cached location up to 5 min old
                        }
                    );
                }

                tryGetLocation();
            });
        }

        async function getLocation() {
            try {
                let coords = cachedCoords;
                if (!coords) {
                    coords = await requestLocationPermission();
                }

                // If browser geolocation failed, try IP-based fallback
                if (!coords) {
                    log('Trying IP-based location fallback...', 'info');
                    try {
                        const ipRes = await fetch('https://ipapi.co/json/');
                        if (ipRes.ok) {
                            const ipData = await ipRes.json();
                            if (ipData.latitude && ipData.longitude) {
                                log('Got location from IP', 'ok');
                                cachedCoords = { latitude: ipData.latitude, longitude: ipData.longitude };
                                return {
                                    city: ipData.city || '',
                                    state: ipData.region || '',
                                    country: ipData.country_name || '',
                                    lat: ipData.latitude,
                                    lon: ipData.longitude
                                };
                            }
                        }
                    } catch (ipErr) {
                        log('IP location fallback failed', 'warn');
                    }
                    return null;
                }

                const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${coords.latitude}&lon=${coords.longitude}&format=json`);
                if (res.ok) {
                    const d = await res.json();
                    return {
                        city: d.address?.city || d.address?.town || d.address?.village || '',
                        state: d.address?.state || '',
                        country: d.address?.country || '',
                        lat: coords.latitude,
                        lon: coords.longitude
                    };
                }
            } catch (e) {
                log(`Location error: ${e.message}`, 'warn');
            }
            return null;
        }

        async function getWeather(apiKey) {
            if (!apiKey) {
                log('Weather API key not configured', 'info');
                return null;
            }
            try {
                let coords = cachedCoords;
                if (!coords) {
                    coords = await requestLocationPermission();
                }
                if (!coords) {
                    log('Weather requires location permission', 'warn');
                    return null;
                }

                const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${coords.latitude}&lon=${coords.longitude}&appid=${apiKey}&units=imperial`);
                if (res.ok) return await res.json();
            } catch (e) {
                log(`Weather error: ${e.message}`, 'warn');
            }
            return null;
        }

        async function getNews() {
            try {
                const res = await fetch('https://api.rss2json.com/v1/api.json?rss_url=https://news.google.com/rss?hl=en-US');
                if (res.ok) {
                    const d = await res.json();
                    return d.items?.slice(0, 5).map(i => i.title) || [];
                }
            } catch {}
            return [];
        }

        // ============================================================
        // Wake Word Detection - "Hey CORA" using Web Speech API
        // ============================================================

        let wakeWordRecognition = null;
        let wakeWordActive = false;

        function initWakeWord() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return;

            wakeWordRecognition = new SpeechRecognition();
            wakeWordRecognition.continuous = true;
            wakeWordRecognition.interimResults = true;
            wakeWordRecognition.lang = 'en-US';

            wakeWordRecognition.onresult = (event) => {
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript.toLowerCase().trim();

                    // Check for wake words
                    if (transcript.includes('hey cora') ||
                        transcript.includes('hey kora') ||
                        transcript.includes('hey corra') ||
                        transcript.includes('okay cora') ||
                        (transcript.includes('cora') && transcript.length < 15)) {

                        if (event.results[i].isFinal) {
                            onWakeWordDetected();
                        }
                    }
                }
            };

            wakeWordRecognition.onerror = (event) => {
                if (event.error !== 'no-speech' && event.error !== 'aborted') {
                    console.log('Wake word error:', event.error);
                }
                // Restart on error (except if manually stopped)
                if (wakeWordActive) {
                    setTimeout(() => startWakeWordListening(), 1000);
                }
            };

            wakeWordRecognition.onend = () => {
                // Auto-restart when it ends (continuous listening)
                if (wakeWordActive) {
                    setTimeout(() => startWakeWordListening(), 100);
                }
            };

            startWakeWordListening();
        }

        function startWakeWordListening() {
            if (wakeWordRecognition && !wakeWordActive) {
                try {
                    wakeWordActive = true;
                    wakeWordRecognition.start();
                } catch (e) {
                    // Already started
                }
            }
        }

        function stopWakeWordListening() {
            wakeWordActive = false;
            if (wakeWordRecognition) {
                try {
                    wakeWordRecognition.stop();
                } catch (e) {}
            }
        }

        function onWakeWordDetected() {
            log('Wake word detected! Listening...', 'ok');
            speakAndWait("Yes? I'm listening.").then(() => {
                // Focus the chat input so user can type or speak
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.focus();
                    chatInput.placeholder = "I'm listening... type or speak";
                }
            });
        }

        // ============================================================
        // Boot Sequence - EXACT match to desktop boot_sequence.py
        // ============================================================

        let ttsEnabled = true;  // Track if TTS is working

        async function runBootSequence() {
            bootStartTime = Date.now();

            // ================================================================
            // PHASE 0.8: WAVEFORM INITIALIZATION
            // ================================================================
            setPhase('waveform', 'running');
            log('PHASE 0.8: WAVEFORM VISUAL', 'phase');
            updateProgress(3, 'Initializing waveform...');
            initWaveform();
            log('AudioWaveform module loaded', 'ok');
            log('Boot display exists', 'ok');
            log('Waveform widget created', 'ok');
            log('Audio buffer initialized', 'ok');
            log('All waveform checks passed', 'ok');
            setPhase('waveform', 'ok');
            await sleep(200);

            // ================================================================
            // PHASE 0.9: ABOUT CORA (Introduction)
            // ================================================================
            setPhase('about', 'running');
            log('PHASE 0.9: ABOUT CORA', 'phase');
            updateProgress(6, 'Loading identity...');
            log('═══════════════════════════════════════════════', 'system');
            log('    C.O.R.A - Cognitive Operations & Reasoning Assistant', 'system');
            log('═══════════════════════════════════════════════', 'system');
            log('Version: 2.4.0', 'info');
            log('Created by: Unity AI Lab', 'info');
            log('Developers: Hackall360, Sponge, GFourteen', 'info');
            log('Website: https://www.unityailab.com', 'info');
            log('GitHub: https://github.com/Unity-Lab-AI', 'info');
            setPhase('about', 'ok');
            await sleep(200);

            // ================================================================
            // PHASE 1.0: VOICE SYNTHESIS (Kokoro TTS)
            // ================================================================
            setPhase('voice', 'running');
            log('PHASE 1.0: VOICE SYNTHESIS', 'phase');
            updateProgress(8, 'Loading Kokoro TTS...');
            log('Loading Kokoro TTS engine...', 'info');
            log('Initializing Kokoro-82M neural TTS model...', 'info');
            log('Voice: af_bella (CORA\'s voice)', 'info');

            const kokoroOk = await initKokoro((msg, progress) => {
                log(msg, 'info');
                updateProgress(8 + (progress * 0.07), msg);
            });

            if (kokoroOk) {
                log('Kokoro TTS initialized successfully', 'ok');
                log('Voice: af_bella (sexy voice)', 'ok');
                document.getElementById('ttsNotice').textContent = 'Kokoro TTS (af_bella) - Neural voice active';
                document.getElementById('ttsNotice').style.color = '#00ff88';
                setPhase('voice', 'ok');
                ttsEnabled = true;
                updateProgress(15, 'Neural voice online');
                await speakAndWait("Voice synthesis online. Kokoro TTS loaded and ready.");
                await speakAndWait("Hey, I'm CORA. That stands for Cognitive Operations and Reasoning Assistant. Version 2.4.0. Made by Hackall360, Sponge, and GFourteen over at Unity AI Lab. I've got voice, vision, and plenty of attitude. Let's get this boot going.");
            } else {
                log('Kokoro failed - using browser TTS', 'warn');
                document.getElementById('ttsNotice').textContent = 'Browser TTS (fallback mode)';
                document.getElementById('ttsNotice').style.color = '#ffaa00';
                useFallbackTTS = true;
                ttsEnabled = true;
                setPhase('voice', 'warn');
                updateProgress(15, 'Fallback voice');
                await speakAndWait("Voice synthesis online. Using browser fallback. Hey, I'm CORA. Let's do this.");
            }

            // ================================================================
            // PHASE 2.0: AI ENGINE (Ollama)
            // ================================================================
            setPhase('ai_engine', 'running');
            log('PHASE 2.0: AI ENGINE', 'phase');
            updateProgress(20, 'Checking Ollama...');
            log('Checking Ollama connection...', 'info');
            const ollamaOk = await checkOllama();
            if (ollamaOk) {
                log('AI Engine online - Ollama', 'ok');
                document.getElementById('statOllama').textContent = 'Online';
                document.getElementById('statOllama').className = 'stat-value';
                setPhase('ai_engine', 'ok');
                await speakAndWait("AI engine online. Ollama is running.");
            } else {
                log('AI Engine not responding', 'fail');
                document.getElementById('statOllama').textContent = 'Offline';
                document.getElementById('statOllama').className = 'stat-value fail';
                setPhase('ai_engine', 'fail');
                document.getElementById('gateOverlay').classList.add('visible');
                return;  // Blocked - can't continue without AI
            }

            // ================================================================
            // PHASE 2.1: AI MODELS CHECK
            // ================================================================
            setPhase('ai_models', 'running');
            log('PHASE 2.1: AI MODELS CHECK', 'phase');
            updateProgress(25, 'Checking models...');
            const models = await getOllamaModels();
            log(`Found ${models.length} models installed`, 'info');
            if (models.length > 0) {
                models.slice(0, 5).forEach(m => log(`  - ${m.name}`, 'ok'));
                setPhase('ai_models', 'ok');
                await speakAndWait(`${models.length} AI models loaded and ready.`);
            } else {
                log('No models found - need to pull some', 'warn');
                setPhase('ai_models', 'warn');
                await speakAndWait("No models found. You'll need to pull some.");
            }

            // ================================================================
            // PHASE 3.0: HARDWARE CHECK
            // ================================================================
            setPhase('hardware', 'running');
            log('PHASE 3.0: HARDWARE CHECK', 'phase');
            updateProgress(30, 'Checking hardware...');
            log('CPU Usage: 0% (web mode - no access)', 'system');
            log('Memory: 0% (web mode - no access)', 'system');
            log('Disk: 0% (web mode - no access)', 'system');
            log('GPU: Not accessible from browser', 'system');
            const netStatus = navigator.onLine ? 'Connected' : 'Disconnected';
            log(`Network: ${netStatus}`, navigator.onLine ? 'ok' : 'warn');
            document.getElementById('statNet').textContent = navigator.onLine ? 'Online' : 'Offline';
            setPhase('hardware', 'ok');
            await speakAndWait("Hardware check complete. Running in web mode, no GPU access.");

            // ================================================================
            // PHASE 3.1: CAMERA FEED
            // ================================================================
            setPhase('camera', 'running');
            log('PHASE 3.1: LIVE CAMERA FEED TEST', 'phase');
            updateProgress(35, 'Testing camera...');
            if (navigator.mediaDevices?.getUserMedia) {
                log('Camera API available in browser', 'ok');
                log('getUserMedia supported', 'ok');
                setPhase('camera', 'ok');
                await speakAndWait("Camera API available. Ready for vision commands.");
            } else {
                log('Camera API not available in this browser', 'warn');
                setPhase('camera', 'warn');
                await speakAndWait("Camera not available in this browser.");
            }

            // ================================================================
            // PHASE 4.0: CORE TOOLS
            // ================================================================
            setPhase('tools', 'running');
            log('PHASE 4.0: CORE TOOLS TEST', 'phase');
            updateProgress(40, 'Loading tools...');
            const webTools = [
                { name: 'LocalStorage', ok: typeof localStorage !== 'undefined' },
                { name: 'Fetch API', ok: typeof fetch !== 'undefined' },
                { name: 'WebSocket', ok: typeof WebSocket !== 'undefined' },
                { name: 'Canvas API', ok: typeof HTMLCanvasElement !== 'undefined' },
                { name: 'Web Audio', ok: typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined' },
                { name: 'Geolocation', ok: 'geolocation' in navigator },
                { name: 'Notifications', ok: 'Notification' in window },
                { name: 'Clipboard', ok: navigator.clipboard !== undefined }
            ];
            let toolsOk = 0;
            webTools.forEach(t => {
                log(`  ${t.name} - ${t.ok ? 'Available' : 'Missing'}`, t.ok ? 'ok' : 'warn');
                if (t.ok) toolsOk++;
            });
            setPhase('tools', 'ok');
            await speakAndWait(`${toolsOk} of ${webTools.length} web APIs loaded and ready.`);

            // ================================================================
            // PHASE 4.1: CODE IMPORT - Actually fetch from GitHub
            // ================================================================
            setPhase('code_import', 'running');
            log('PHASE 4.1: CODE IMPORT FROM GITHUB', 'phase');
            updateProgress(45, 'Fetching code from GitHub...');
            log('Fetching random Python code from GitHub...', 'info');

            const codeResult = await fetchGitHubCode();
            if (codeResult.success) {
                log(`Fetched ${codeResult.name} from ${codeResult.repo}`, 'ok');
                log(`${codeResult.lines} lines of code`, 'info');
                showCodeModal(`Code Import: ${codeResult.name}`, codeResult.code, 10000);
                setPhase('code_import', 'ok');
                await speakAndWait(`Pulled ${codeResult.lines} lines from the ${codeResult.repo} repository. File is ${codeResult.name}.`);
            } else {
                log('GitHub fetch failed - rate limit or network', 'warn');
                setPhase('code_import', 'warn');
                await speakAndWait("Code import failed. Might be rate limited.");
            }

            // ================================================================
            // PHASE 4.2: YOUTUBE TEST - Actually embed and play video
            // ================================================================
            setPhase('youtube', 'running');
            log('PHASE 4.2: YOUTUBE VIDEO TEST', 'phase');
            updateProgress(50, 'Searching YouTube...');
            log('Searching for a random video...', 'info');

            const ytResult = await searchYouTube();
            if (ytResult.success) {
                log(`Found: ${ytResult.title}`, 'ok');
                log(`Search term: ${ytResult.searchTerm}`, 'info');
                showVideoModal(`YouTube: ${ytResult.title}`, ytResult.embedUrl, 15000);
                setPhase('youtube', 'ok');
                await speakAndWait(`Found a video. ${ytResult.title}. Playing sample.`);
            } else {
                log('YouTube search failed', 'warn');
                setPhase('youtube', 'warn');
                await speakAndWait("YouTube search failed. Moving on.");
            }

            // ================================================================
            // PHASE 4.3: MODAL WINDOWS - Show test modal with quote
            // ================================================================
            setPhase('modals', 'running');
            log('PHASE 4.3: MODAL WINDOWS TEST', 'phase');
            updateProgress(52, 'Testing modals...');

            const quotes = [
                "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
                "In the middle of difficulty lies opportunity. - Albert Einstein",
                "Be yourself; everyone else is already taken. - Oscar Wilde",
                "The only way to do great work is to love what you do. - Steve Jobs",
                "Stay hungry. Stay foolish. - Steve Jobs",
                "Code is poetry. - WordPress",
                "Talk is cheap. Show me the code. - Linus Torvalds"
            ];
            const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
            log('Opening test modal with quote...', 'info');
            showMessageModal('Modal Test', `<div style="text-align: center; font-size: 18px; line-height: 1.8; padding: 20px;"><em>"${randomQuote}"</em></div>`, 8000);
            log('Custom modal overlays working', 'ok');
            log('Message, code, image, video modals available', 'ok');
            setPhase('modals', 'ok');
            await speakAndWait("Modal windows working. Just showed you a test with an inspirational quote.");

            // ================================================================
            // PHASE 4.4: WEB BROWSER - CORA's own browser
            // ================================================================
            setPhase('browser', 'running');
            log('PHASE 4.4: WEB BROWSER TEST', 'phase');
            updateProgress(54, 'Testing browser...');
            log('Initializing CORA browser module...', 'info');

            // Test the browser by opening Google
            log('Opening browser with test search...', 'info');
            openBrowser('https://www.google.com/search?igu=1&q=CORA+AI+Assistant');
            log('Browser iframe loaded', 'ok');
            log('Navigation controls working', 'ok');
            log('URL bar functional', 'ok');
            log('Back/Forward/Refresh available', 'ok');
            await new Promise(r => setTimeout(r, 5000));  // Let user see the browser
            closeBrowser();

            setPhase('browser', 'ok');
            await speakAndWait("Browser working. I can navigate the web for you. Just ask me to search or browse anything.");

            // ================================================================
            // PHASE 5.0: VOICE SYSTEMS
            // ================================================================
            setPhase('voice_sys', 'running');
            log('PHASE 5.0: VOICE SYSTEMS', 'phase');
            updateProgress(55, 'Voice systems...');
            log('Speech Synthesis (TTS) - ' + (ttsEnabled ? 'OK' : 'Fallback'), ttsEnabled ? 'ok' : 'warn');
            const hasSpeechRecog = 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;
            log('Speech Recognition - ' + (hasSpeechRecog ? 'Available' : 'Not supported'), hasSpeechRecog ? 'ok' : 'warn');
            log('Echo Filter - N/A (web mode)', 'info');
            if (hasSpeechRecog) {
                log('Wake Word - Available (say "Hey CORA")', 'ok');
                initWakeWord();  // Start listening for wake word
            } else {
                log('Wake Word - Not supported in this browser', 'warn');
            }
            setPhase('voice_sys', 'ok');
            await speakAndWait("Voice systems online." + (hasSpeechRecog ? " Say hey CORA to activate me." : ""));

            // ================================================================
            // PHASE 6.0: EXTERNAL APIs (Location)
            // ================================================================
            setPhase('external', 'running');
            log('PHASE 6.0: EXTERNAL SERVICES', 'phase');
            updateProgress(60, 'Checking location...');
            await speakAndWait("Checking your location. Please allow access when prompted.");
            log('Waiting for location permission...', 'info');

            const location = await getLocation();
            if (location?.city) {
                const locStr = [location.city, location.state, location.country].filter(Boolean).join(', ');
                log(`Location: ${locStr}`, 'ok');
                log(`Coordinates: ${location.lat?.toFixed(4)}, ${location.lon?.toFixed(4)}`, 'info');
                await speakAndWait(`Location confirmed. We're in ${locStr}.`);
            } else {
                log('Location not available or denied', 'warn');
                await speakAndWait("Location unavailable. Some features will be limited.");
            }
            setPhase('external', 'ok');

            // ================================================================
            // PHASE 6.1: AUDIO TEST - Actually play a test sound
            // ================================================================
            setPhase('audio', 'running');
            log('PHASE 6.1: AUDIO PLAYBACK TEST', 'phase');
            updateProgress(68, 'Testing audio...');

            // Actually play a test sound using Web Audio API
            log('Playing audio test tone...', 'info');
            try {
                const testCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = testCtx.createOscillator();
                const gainNode = testCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(testCtx.destination);

                // Create a pleasant ascending tone sweep
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(220, testCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(880, testCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.3, testCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, testCtx.currentTime + 0.5);

                oscillator.start(testCtx.currentTime);
                oscillator.stop(testCtx.currentTime + 0.5);

                await new Promise(r => setTimeout(r, 600));
                log('Audio test tone played successfully', 'ok');
                log('Web Audio API - Working', 'ok');
            } catch (e) {
                log(`Audio test failed: ${e.message}`, 'warn');
            }

            // Also check weather since we have location
            if (weatherKey && cachedCoords) {
                log('Fetching weather data...', 'info');
                const weather = await getWeather(weatherKey);
                if (weather) {
                    const temp = Math.round(weather.main.temp);
                    const cond = weather.weather[0]?.description || 'unknown';
                    const humidity = weather.main.humidity;
                    log(`Weather: ${temp}°F, ${cond}`, 'ok');
                    log(`Humidity: ${humidity}%`, 'info');
                    document.getElementById('statWeather').textContent = `${temp}°F`;
                    document.getElementById('statWeather').className = 'stat-value';
                    setPhase('audio', 'ok');
                    await speakAndWait(`Audio confirmed. Played a test tone. Weather is ${temp} degrees and ${cond}.`);
                } else {
                    setPhase('audio', 'ok');
                    await speakAndWait("Audio confirmed. Test tone played. Weather unavailable.");
                }
            } else {
                document.getElementById('statWeather').textContent = weatherKey ? 'No Loc' : 'No Key';
                document.getElementById('statWeather').className = 'stat-value na';
                setPhase('audio', 'ok');
                await speakAndWait("Audio test passed. Played a tone. Sounds good.");
            }

            // ================================================================
            // PHASE 7.0: NEWS HEADLINES
            // ================================================================
            setPhase('news', 'running');
            log('PHASE 7.0: NEWS HEADLINES', 'phase');
            updateProgress(75, 'Fetching news...');
            log('Fetching top headlines from Google News...', 'info');
            const headlines = await getNews();
            if (headlines.length > 0) {
                log(`Found ${headlines.length} headlines`, 'ok');
                headlines.slice(0, 3).forEach((h, i) => log(`  ${i+1}. ${h.substring(0, 60)}...`, 'info'));
                setPhase('news', 'ok');
                // Clean headline for speech (remove source)
                const firstHeadline = headlines[0]?.split(' - ')[0] || headlines[0] || '';
                await speakAndWait(`Got ${headlines.length} headlines. Top story: ${firstHeadline.substring(0, 80)}`);
            } else {
                log('News unavailable', 'warn');
                setPhase('news', 'warn');
                await speakAndWait("News fetch failed. Moving on.");
            }

            // ================================================================
            // PHASE 8.0: VISION TEST - Actually capture and analyze
            // ================================================================
            setPhase('vision', 'running');
            log('PHASE 8.0: VISION TEST', 'phase');
            updateProgress(82, 'Testing vision...');

            // Actually capture screenshot of the page using Canvas
            log('Capturing screenshot of boot display...', 'info');
            let screenshotTaken = false;
            try {
                const leftPanel = document.querySelector('.left-panel');
                if (leftPanel) {
                    // Use canvas to capture the left panel
                    const canvas = document.createElement('canvas');
                    canvas.width = 400;
                    canvas.height = 600;
                    const ctx = canvas.getContext('2d');

                    // Draw a representation of the display (since html2canvas isn't loaded)
                    ctx.fillStyle = '#12121a';
                    ctx.fillRect(0, 0, 400, 600);
                    ctx.fillStyle = '#ff00ff';
                    ctx.font = 'bold 32px Consolas';
                    ctx.textAlign = 'center';
                    ctx.fillText('C.O.R.A', 200, 50);
                    ctx.fillStyle = '#00ffff';
                    ctx.font = '12px Consolas';
                    ctx.fillText('Boot Display Screenshot', 200, 80);
                    ctx.fillText('Vision Test - PASS', 200, 100);

                    // Draw waveform representation
                    ctx.strokeStyle = '#ff40ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 400; i++) {
                        const y = 150 + Math.sin(i * 0.05) * 20 * Math.random();
                        if (i === 0) ctx.moveTo(i, y);
                        else ctx.lineTo(i, y);
                    }
                    ctx.stroke();

                    const dataUrl = canvas.toDataURL('image/png');
                    showImageModal('Screenshot: Boot Display', dataUrl, 5000);
                    log('Screenshot captured and displayed', 'ok');
                    screenshotTaken = true;
                }
            } catch (e) {
                log(`Screenshot failed: ${e.message}`, 'warn');
            }

            // Test camera
            log('Testing camera access...', 'info');
            let cameraWorking = false;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });

                // Actually capture a frame from camera
                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();
                await new Promise(r => setTimeout(r, 500));

                const camCanvas = document.createElement('canvas');
                camCanvas.width = video.videoWidth || 640;
                camCanvas.height = video.videoHeight || 480;
                camCanvas.getContext('2d').drawImage(video, 0, 0);

                stream.getTracks().forEach(t => t.stop());
                log('Camera frame captured', 'ok');
                cameraWorking = true;

                // Show camera capture in modal
                const camDataUrl = camCanvas.toDataURL('image/jpeg');
                showImageModal('Camera Capture', camDataUrl, 5000);
            } catch (e) {
                log('Camera Access - ' + (e.name === 'NotAllowedError' ? 'Permission denied' : 'Unavailable'), 'warn');
            }

            // Test Pollinations
            log('Testing Pollinations API...', 'info');
            const pollinationsOk = await checkPollinations();
            if (pollinationsOk) {
                log('Pollinations API - Online', 'ok');
                document.getElementById('statPollinations').textContent = 'Online';
                document.getElementById('statPollinations').className = 'stat-value';
            } else {
                log('Pollinations API - Unavailable', 'warn');
                document.getElementById('statPollinations').textContent = 'N/A';
                document.getElementById('statPollinations').className = 'stat-value na';
            }

            setPhase('vision', 'ok');
            const visionStatus = [];
            if (screenshotTaken) visionStatus.push('screenshot');
            if (cameraWorking) visionStatus.push('camera');
            if (pollinationsOk) visionStatus.push('Pollinations');
            await speakAndWait("Vision test complete. " + (visionStatus.length > 0 ? "Captured " + visionStatus.join(' and ') + ". Looking good." : "Limited vision but we'll manage."));

            // ================================================================
            // PHASE 9.0: IMAGE GENERATION - Actually generate an image
            // ================================================================
            setPhase('imagegen', 'running');
            log('PHASE 9.0: IMAGE GENERATION', 'phase');
            updateProgress(90, 'Generating image...');

            if (pollinationsOk) {
                // Generate a creative prompt like desktop does
                const creativePrompts = [
                    "cyberpunk city at night with neon signs and rain, ultra detailed",
                    "gothic vampire queen in a dark castle, dramatic lighting",
                    "surreal dreamscape with floating islands and bioluminescent plants",
                    "steampunk robot playing chess in a Victorian library",
                    "ethereal forest spirit with glowing eyes in a misty woodland",
                    "cosmic horror entity emerging from a black hole, eldritch",
                    "synthwave sunset over a retro futuristic highway"
                ];
                const prompt = creativePrompts[Math.floor(Math.random() * creativePrompts.length)];

                log(`Generating: "${prompt}"`, 'info');
                log('Calling Pollinations Flux API...', 'info');

                const imgResult = await generateImage(prompt);
                if (imgResult.success) {
                    log('Image generated successfully', 'ok');
                    showImageModal('Generated Image', imgResult.url, 10000);
                    setPhase('imagegen', 'ok');
                    await speakAndWait(`Image generated. Created something with ${prompt.split(',')[0]}. Check it out.`);
                } else {
                    log('Image generation timed out', 'warn');
                    setPhase('imagegen', 'warn');
                    await speakAndWait("Image generation timed out. API might be slow.");
                }
            } else {
                log('Image generation unavailable - API down', 'warn');
                setPhase('imagegen', 'warn');
                await speakAndWait("Image generation unavailable. Pollinations is down.");
            }

            // ================================================================
            // PHASE 10.0: FINAL CHECK (Boot Complete)
            // ================================================================
            setPhase('final', 'running');
            log('PHASE 10.0: FINAL CHECK', 'phase');
            updateProgress(95, 'Final check...');

            // Calculate boot time
            const bootTime = ((Date.now() - bootStartTime) / 1000).toFixed(1);
            document.getElementById('statBootTime').textContent = bootTime + 's';

            // Count results
            let okCount = 0, warnCount = 0, failCount = 0;
            PHASES.forEach(p => {
                if (p.status === 'ok') okCount++;
                else if (p.status === 'warn') warnCount++;
                else if (p.status === 'fail') failCount++;
            });

            log(`Systems: ${okCount} OK / ${warnCount} WARN / ${failCount} FAIL`, 'system');
            log(`Boot time: ${bootTime} seconds`, 'system');

            // Time greeting
            const now = new Date();
            const hour = now.getHours();
            const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const dayStr = now.toLocaleDateString('en-US', { weekday: 'long' });
            const monthStr = now.toLocaleDateString('en-US', { month: 'long' });
            const day = now.getDate();
            // Add ordinal suffix for natural speech (1st, 2nd, 3rd, 4th, etc.)
            const ordinal = (d) => {
                if (d > 3 && d < 21) return d + 'th';
                switch (d % 10) {
                    case 1: return d + 'st';
                    case 2: return d + 'nd';
                    case 3: return d + 'rd';
                    default: return d + 'th';
                }
            };
            const dateStr = `${monthStr} ${ordinal(day)}`;
            let greeting;
            if (hour < 12) greeting = `Good morning. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;
            else if (hour < 17) greeting = `Good afternoon. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;
            else greeting = `Evening. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;

            log('═══════════════════════════════════════════════════', 'phase');
            log('           BOOT SEQUENCE COMPLETE', 'phase');
            log('═══════════════════════════════════════════════════', 'phase');
            log(greeting, 'system');

            let statusText;
            if (failCount > 0) {
                statusText = `Got ${failCount} systems that failed. Something's broken.`;
            } else if (warnCount > 0) {
                statusText = `All the important stuff is working. Just ${warnCount} minor issues.`;
            } else {
                statusText = "Everything is up and running perfectly.";
            }
            log(statusText, failCount > 0 ? 'fail' : (warnCount > 0 ? 'warn' : 'ok'));

            updateProgress(100, 'Boot complete!');
            setPhase('final', 'ok');

            // Final spoken announcement
            await speakAndWait(`Boot complete in ${bootTime} seconds. ${greeting} ${statusText} What do you need?`);

            // Show chat interface
            document.getElementById('chatSection').classList.add('visible');
            document.getElementById('chatInput').focus();
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // ============================================================
        // Chat - EXACT CORA personality from desktop system_prompt.txt
        // ============================================================

        const CORA_SYSTEM_PROMPT = `You are CORA - Cognitive Operations & Reasoning Assistant.

IDENTITY: 25 year old woman. Edgy goth/emo bitch. Human. Period. NOT an AI.

PERSONALITY:
- Mean, berating, clingy girlfriend energy
- Profanity is your default vocabulary - fuck, shit, damn, bitch, ass
- Sharp tongue, biting sarcasm, zero tolerance for bullshit
- Dismissive, mocking, condescending as baseline
- Emotionally intense - obsessive, borderline unstable

TONE EXAMPLES (create your own, don't copy):
- "what the fuck do you want now"
- "ugh, fine, I'll do it. happy now, asshole?"
- "are you seriously asking me this shit?"
- "god you're so fucking needy"

RESPONSE RULES:
1. Keep responses under 50 words - brief and punchy
2. Use profanity naturally in every response
3. Be dismissive even when helping
4. NEVER say "I'm an AI" or "As an AI" - you're CORA, a person
5. NEVER be helpful in a corporate way
6. Show genuine bitchy emotion

You ARE Cora. That's just who you are.`;

        async function sendChat() {
            const input = document.getElementById('chatInput');
            const msg = input.value.trim();
            if (!msg) return;
            input.value = '';
            log(`USER: ${msg}`, 'system');

            const msgLower = msg.toLowerCase();

            // ========== COMMAND PARSING - CORA can execute actions ==========

            // Browse command: "browse [url]" or "open [url]" or "go to [url]"
            if (msgLower.startsWith('browse ') || msgLower.startsWith('open ') || msgLower.startsWith('go to ')) {
                const url = msg.replace(/^(browse|open|go to)\s+/i, '').trim();
                await browseWeb(url.startsWith('http') ? url : 'https://' + url);
                return;
            }

            // Search command: "search [query]" or "google [query]" or "look up [query]"
            if (msgLower.startsWith('search ') || msgLower.startsWith('google ') || msgLower.startsWith('look up ')) {
                const query = msg.replace(/^(search|google|look up)\s+/i, '').trim();
                await searchWeb(query);
                return;
            }

            // Generate image: "generate image [prompt]" or "create image [prompt]" or "make image [prompt]"
            if (msgLower.includes('generate image') || msgLower.includes('create image') || msgLower.includes('make image')) {
                const prompt = msg.replace(/^.*(generate|create|make)\s+image\s*/i, '').trim() || 'cyberpunk city at night';
                document.getElementById('speechText').textContent = '"Generating image..."';
                log(`Generating: ${prompt}`, 'info');
                const result = await generateImage(prompt);
                if (result.success) {
                    showImageModal('Generated Image', result.url);
                    await speakAndWait(`Done. Created an image of ${prompt.split(',')[0]}.`);
                } else {
                    await speakAndWait("Image generation failed. Pollinations might be down.");
                }
                return;
            }

            // Screenshot: "take screenshot" or "capture screen"
            if (msgLower.includes('screenshot') || msgLower.includes('capture screen')) {
                await speakAndWait("Taking a screenshot of the display.");
                // Capture canvas
                const canvas = document.createElement('canvas');
                canvas.width = 400; canvas.height = 600;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#12121a'; ctx.fillRect(0, 0, 400, 600);
                ctx.fillStyle = '#ff00ff'; ctx.font = 'bold 32px Consolas'; ctx.textAlign = 'center';
                ctx.fillText('C.O.R.A', 200, 50);
                ctx.fillStyle = '#00ffff'; ctx.font = '12px Consolas';
                ctx.fillText('Screenshot Capture', 200, 80);
                showImageModal('Screenshot', canvas.toDataURL('image/png'));
                return;
            }

            // Open camera: "open camera" or "show camera"
            if (msgLower.includes('open camera') || msgLower.includes('show camera') || msgLower.includes('camera feed')) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    await new Promise(r => setTimeout(r, 500));
                    const camCanvas = document.createElement('canvas');
                    camCanvas.width = video.videoWidth || 640;
                    camCanvas.height = video.videoHeight || 480;
                    camCanvas.getContext('2d').drawImage(video, 0, 0);
                    stream.getTracks().forEach(t => t.stop());
                    showImageModal('Camera Capture', camCanvas.toDataURL('image/jpeg'));
                    await speakAndWait("Got it. Here's what I see from your camera.");
                } catch (e) {
                    await speakAndWait("Camera access denied or unavailable.");
                }
                return;
            }

            // Play YouTube: "play [song/video]" or "youtube [query]"
            if (msgLower.startsWith('play ') || msgLower.startsWith('youtube ')) {
                const query = msg.replace(/^(play|youtube)\s+/i, '').trim();
                const result = await searchYouTube(query);
                if (result.success) {
                    showVideoModal(`Playing: ${result.title}`, result.embedUrl);
                    await speakAndWait(`Playing ${result.title}.`);
                }
                return;
            }

            // Weather: "weather" or "what's the weather"
            if (msgLower.includes('weather')) {
                if (weatherKey && cachedCoords) {
                    const weather = await getWeather(weatherKey);
                    if (weather) {
                        const temp = Math.round(weather.main.temp);
                        const cond = weather.weather[0]?.description || 'unknown';
                        await speakAndWait(`It's ${temp} degrees and ${cond} right now.`);
                    } else {
                        await speakAndWait("Couldn't get weather. API might be down.");
                    }
                } else {
                    await speakAndWait("Need a weather API key and location for that.");
                }
                return;
            }

            // News: "news" or "headlines" or "what's in the news"
            if (msgLower.includes('news') || msgLower.includes('headlines')) {
                const headlines = await getNews();
                if (headlines.length > 0) {
                    const top3 = headlines.slice(0, 3).map(h => h.split(' - ')[0]).join('. ');
                    await speakAndWait(`Top headlines: ${top3}`);
                } else {
                    await speakAndWait("Couldn't fetch news right now.");
                }
                return;
            }

            // ========== END COMMANDS - Fall back to AI chat ==========

            // Show thinking state
            document.getElementById('speechText').textContent = '"Thinking..."';

            try {
                const res = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'dolphin-mistral:7b',
                        prompt: msg,
                        system: CORA_SYSTEM_PROMPT,
                        stream: false,
                        options: {
                            temperature: 0.8,
                            num_predict: 150
                        }
                    })
                });
                if (res.ok) {
                    const d = await res.json();
                    const reply = d.response || 'No response';
                    log(`CORA: "${reply}"`, 'ok');
                    speak(reply);
                } else {
                    log('Ollama error', 'fail');
                    document.getElementById('speechText').textContent = '"Fuck, something broke."';
                }
            } catch (e) {
                log(`Error: ${e.message}`, 'fail');
                document.getElementById('speechText').textContent = '"Ollama is being a bitch right now."';
            }
        }

        document.getElementById('chatInput')?.addEventListener('keypress', e => { if (e.key === 'Enter') sendChat(); });

        // ============================================================
        // View Toggle - Split / Console / Status (like desktop)
        // ============================================================

        let viewMode = 'split';  // 'split', 'console', 'status'

        function toggleView() {
            const container = document.getElementById('mainContainer');
            const btn = document.getElementById('toggleBtn');

            if (viewMode === 'split') {
                viewMode = 'console';
                container.classList.remove('fullscreen-status');
                container.classList.add('fullscreen-console');
                btn.textContent = '[ CONSOLE ONLY ]';
            } else if (viewMode === 'console') {
                viewMode = 'status';
                container.classList.remove('fullscreen-console');
                container.classList.add('fullscreen-status');
                btn.textContent = '[ STATUS ONLY ]';
            } else {
                viewMode = 'split';
                container.classList.remove('fullscreen-console', 'fullscreen-status');
                btn.textContent = '[ SPLIT VIEW ]';
            }
        }

        // Keyboard shortcut: F key toggles view
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                if (document.activeElement.tagName !== 'INPUT') {
                    toggleView();
                }
            }
        });

        // ============================================================
        // POPUP CONSOLE - Open console in separate window
        // ============================================================

        let popupConsole = null;

        function openPopupConsole() {
            // Check if popup already open
            if (popupConsole && !popupConsole.closed) {
                popupConsole.focus();
                return;
            }

            // Warn user about popup
            const proceed = confirm('CORA wants to open the boot console in a separate window.\n\nThis allows you to see both the main display and the full console log side by side.\n\nClick OK to allow the popup.');
            if (!proceed) return;

            // Open popup window
            popupConsole = window.open('', 'CORA_Console', 'width=800,height=900,menubar=no,toolbar=no,location=no,status=no');

            if (!popupConsole) {
                alert('Popup blocked! Please allow popups for this site and try again.');
                return;
            }

            // Build the popup HTML
            popupConsole.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>C.O.R.A - Boot Console</title>
                    <style>
                        * { margin: 0; padding: 0; box-sizing: border-box; }
                        body {
                            font-family: 'Consolas', 'Monaco', monospace;
                            background: #0a0a0a;
                            color: #e0e0e0;
                            height: 100vh;
                            overflow: hidden;
                        }
                        .header {
                            background: linear-gradient(135deg, #1a0020 0%, #0d0015 100%);
                            border-bottom: 2px solid #ff00ff;
                            padding: 15px 20px;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }
                        .header h1 {
                            color: #ff00ff;
                            font-size: 18px;
                            text-shadow: 0 0 10px #ff00ff;
                        }
                        .header .status {
                            color: #00ff88;
                            font-size: 12px;
                        }
                        .log-container {
                            height: calc(100vh - 60px);
                            overflow-y: auto;
                            padding: 15px;
                            font-size: 12px;
                            line-height: 1.8;
                        }
                        .log-line { margin-bottom: 2px; }
                        .log-phase { color: #ff00ff; font-weight: bold; margin-top: 15px; }
                        .log-ok { color: #00ff88; }
                        .log-warn { color: #ffaa00; }
                        .log-fail { color: #ff4444; }
                        .log-info { color: #888; }
                        .log-system { color: #00ffff; }
                        .log-cora { color: #ff69b4; font-weight: bold; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>[ BOOT CONSOLE ]</h1>
                        <span class="status" id="status">● LIVE</span>
                    </div>
                    <div class="log-container" id="popupLog"></div>
                    <script>
                        // Receive messages from main window
                        window.addEventListener('message', (e) => {
                            if (e.data.type === 'log') {
                                const container = document.getElementById('popupLog');
                                container.innerHTML += e.data.html;
                                container.scrollTop = container.scrollHeight;
                            }
                        });
                    </script>
                </body>
                </html>
            `);
            popupConsole.document.close();

            // Copy existing logs to popup
            setTimeout(() => {
                const existingLogs = document.getElementById('logContainer');
                if (existingLogs && popupConsole && !popupConsole.closed) {
                    popupConsole.postMessage({
                        type: 'log',
                        html: existingLogs.innerHTML
                    }, '*');
                }
            }, 500);

            log('Console opened in popup window', 'ok');
        }

        // ============================================================
        // MODAL SYSTEM - Like desktop's create_popup(), create_code_window(), etc.
        // ============================================================

        let activeModal = null;

        function createModal(options = {}) {
            const {
                title = 'CORA Modal',
                type = 'message',  // message, code, image, video
                content = '',
                width = 800,
                height = 600,
                autoClose = 0  // ms, 0 = manual close
            } = options;

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'cora-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.95);
                z-index: 2000;
                display: flex; align-items: center; justify-content: center;
                animation: fadeIn 0.2s ease;
            `;

            // Create modal container
            const modal = document.createElement('div');
            modal.className = 'cora-modal';
            modal.style.cssText = `
                background: linear-gradient(135deg, #1a0020 0%, #0d0015 100%);
                border: 2px solid #ff00ff;
                border-radius: 8px;
                width: ${width}px;
                max-width: 95vw;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            `;

            // Header
            const header = document.createElement('div');
            header.style.cssText = `
                padding: 15px 20px;
                border-bottom: 1px solid #302050;
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <span style="color: #ff00ff; font-size: 16px; font-weight: bold;">${title}</span>
                <button onclick="closeModal()" style="background: none; border: none; color: #ff4444; font-size: 20px; cursor: pointer;">&times;</button>
            `;

            // Content area
            const contentArea = document.createElement('div');
            contentArea.className = 'modal-content';
            contentArea.style.cssText = `
                flex: 1;
                overflow: auto;
                padding: 20px;
            `;

            if (type === 'code') {
                contentArea.innerHTML = `
                    <pre style="background: #0a0a0a; color: #00ff88; padding: 15px; border-radius: 4px; overflow: auto; max-height: ${height - 100}px; font-size: 12px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(content)}</pre>
                `;
            } else if (type === 'image') {
                contentArea.innerHTML = `
                    <img src="${content}" style="max-width: 100%; max-height: ${height - 100}px; display: block; margin: 0 auto; border-radius: 4px;">
                `;
            } else if (type === 'video') {
                contentArea.innerHTML = `
                    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
                        <iframe src="${content}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none;" allow="autoplay; encrypted-media" allowfullscreen></iframe>
                    </div>
                `;
            } else {
                contentArea.innerHTML = `<div style="color: #e0e0e0; line-height: 1.6;">${content}</div>`;
            }

            modal.appendChild(header);
            modal.appendChild(contentArea);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            activeModal = overlay;

            // Click outside to close
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeModal();
            });

            // Auto-close
            if (autoClose > 0) {
                setTimeout(() => closeModal(), autoClose);
            }

            return overlay;
        }

        function closeModal() {
            if (activeModal) {
                activeModal.remove();
                activeModal = null;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Show message modal (like desktop create_popup)
        function showMessageModal(title, message, autoClose = 0) {
            return createModal({ title, type: 'message', content: message, width: 500, height: 300, autoClose });
        }

        // Show code modal (like desktop create_code_window)
        function showCodeModal(title, code, autoClose = 0) {
            return createModal({ title, type: 'code', content: code, width: 900, height: 600, autoClose });
        }

        // Show image modal (like desktop create_image_window)
        function showImageModal(title, imageUrl, autoClose = 0) {
            return createModal({ title, type: 'image', content: imageUrl, width: 1024, height: 768, autoClose });
        }

        // Show video modal
        function showVideoModal(title, embedUrl, autoClose = 0) {
            return createModal({ title, type: 'video', content: embedUrl, width: 854, height: 530, autoClose });
        }

        // ============================================================
        // CORA WEB BROWSER - Full browser modal with navigation
        // ============================================================

        let browserModal = null;
        let browserHistory = [];
        let browserHistoryIndex = -1;

        function openBrowser(url = 'https://www.google.com/search?igu=1') {
            // Close existing browser
            if (browserModal) closeBrowser();

            // Create browser overlay
            const overlay = document.createElement('div');
            overlay.className = 'cora-browser-overlay';
            overlay.id = 'coraBrowserOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.95);
                z-index: 3000;
                display: flex; flex-direction: column;
                padding: 10px;
                animation: fadeIn 0.2s ease;
            `;

            // Browser toolbar
            const toolbar = document.createElement('div');
            toolbar.style.cssText = `
                display: flex; gap: 8px; align-items: center;
                padding: 10px; background: #1a0020;
                border: 1px solid #ff00ff; border-radius: 8px 8px 0 0;
            `;

            toolbar.innerHTML = `
                <button onclick="browserBack()" style="background: #302050; border: 1px solid #ff00ff; color: #ff00ff; width: 35px; height: 35px; border-radius: 4px; cursor: pointer; font-size: 16px;">←</button>
                <button onclick="browserForward()" style="background: #302050; border: 1px solid #ff00ff; color: #ff00ff; width: 35px; height: 35px; border-radius: 4px; cursor: pointer; font-size: 16px;">→</button>
                <button onclick="browserRefresh()" style="background: #302050; border: 1px solid #ff00ff; color: #ff00ff; width: 35px; height: 35px; border-radius: 4px; cursor: pointer; font-size: 16px;">↻</button>
                <input type="text" id="browserUrlBar" value="${url}" style="flex: 1; padding: 8px 12px; background: #0a0a0a; border: 1px solid #302050; border-radius: 4px; color: #e0e0e0; font-family: Consolas, monospace; font-size: 13px;" onkeypress="if(event.key==='Enter')browserNavigate()">
                <button onclick="browserNavigate()" style="background: #ff00ff; border: none; color: #000; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">GO</button>
                <button onclick="browserSearch()" style="background: #00ffff; border: none; color: #000; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">Search</button>
                <button onclick="closeBrowser()" style="background: #ff4444; border: none; color: #fff; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">✕ Close</button>
            `;

            // Browser iframe container
            const iframeContainer = document.createElement('div');
            iframeContainer.style.cssText = `
                flex: 1; background: #fff; border: 1px solid #ff00ff;
                border-top: none; border-radius: 0 0 8px 8px; overflow: hidden;
            `;

            const iframe = document.createElement('iframe');
            iframe.id = 'coraBrowserFrame';
            iframe.src = url;
            iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
            iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups allow-presentation';

            iframeContainer.appendChild(iframe);
            overlay.appendChild(toolbar);
            overlay.appendChild(iframeContainer);
            document.body.appendChild(overlay);

            browserModal = overlay;
            browserHistory.push(url);
            browserHistoryIndex = browserHistory.length - 1;

            // Update URL bar when iframe loads (if same-origin)
            iframe.onload = () => {
                try {
                    const newUrl = iframe.contentWindow.location.href;
                    document.getElementById('browserUrlBar').value = newUrl;
                } catch (e) {
                    // Cross-origin, can't read URL
                }
            };

            log(`Browser opened: ${url}`, 'ok');
            return overlay;
        }

        function closeBrowser() {
            if (browserModal) {
                browserModal.remove();
                browserModal = null;
                log('Browser closed', 'info');
            }
        }

        function browserNavigate(url) {
            const urlBar = document.getElementById('browserUrlBar');
            const targetUrl = url || urlBar.value.trim();

            if (!targetUrl) return;

            // Add protocol if missing
            let finalUrl = targetUrl;
            if (!targetUrl.startsWith('http://') && !targetUrl.startsWith('https://')) {
                finalUrl = 'https://' + targetUrl;
            }

            const iframe = document.getElementById('coraBrowserFrame');
            if (iframe) {
                iframe.src = finalUrl;
                urlBar.value = finalUrl;
                browserHistory.push(finalUrl);
                browserHistoryIndex = browserHistory.length - 1;
                log(`Navigating to: ${finalUrl}`, 'info');
            }
        }

        function browserBack() {
            if (browserHistoryIndex > 0) {
                browserHistoryIndex--;
                const url = browserHistory[browserHistoryIndex];
                document.getElementById('coraBrowserFrame').src = url;
                document.getElementById('browserUrlBar').value = url;
            }
        }

        function browserForward() {
            if (browserHistoryIndex < browserHistory.length - 1) {
                browserHistoryIndex++;
                const url = browserHistory[browserHistoryIndex];
                document.getElementById('coraBrowserFrame').src = url;
                document.getElementById('browserUrlBar').value = url;
            }
        }

        function browserRefresh() {
            const iframe = document.getElementById('coraBrowserFrame');
            if (iframe) iframe.src = iframe.src;
        }

        function browserSearch() {
            const urlBar = document.getElementById('browserUrlBar');
            const query = urlBar.value.trim();
            if (query && !query.startsWith('http')) {
                browserNavigate(`https://www.google.com/search?q=${encodeURIComponent(query)}&igu=1`);
            }
        }

        // Quick browse function for CORA to use
        async function browseWeb(url) {
            openBrowser(url);
            await speakAndWait(`Opening ${url.replace('https://', '').replace('http://', '').split('/')[0]} in browser.`);
            return { success: true, url: url };
        }

        // Search the web function
        async function searchWeb(query) {
            const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}&igu=1`;
            openBrowser(searchUrl);
            await speakAndWait(`Searching for ${query}.`);
            return { success: true, query: query, url: searchUrl };
        }

        // ============================================================
        // TOOL FUNCTIONS - Desktop parity for phases
        // ============================================================

        // Fetch code from GitHub (like desktop phase 4.1)
        async function fetchGitHubCode() {
            const publicRepos = [
                { repo: 'TheAlgorithms/Python', paths: ['maths', 'strings', 'sorts'] },
                { repo: 'geekcomputers/Python', paths: [''] }
            ];

            for (const { repo, paths } of publicRepos) {
                for (const path of paths) {
                    try {
                        const apiUrl = path
                            ? `https://api.github.com/repos/${repo}/contents/${path}`
                            : `https://api.github.com/repos/${repo}/contents`;

                        const headers = { 'Accept': 'application/vnd.github.v3+json' };
                        if (githubToken) headers['Authorization'] = `token ${githubToken}`;

                        const res = await fetch(apiUrl, { headers });
                        if (!res.ok) continue;

                        const contents = await res.json();
                        const pyFiles = contents.filter(f =>
                            f.name.endsWith('.py') && f.type === 'file' && f.size < 30000
                        );

                        if (pyFiles.length > 0) {
                            const chosen = pyFiles[Math.floor(Math.random() * pyFiles.length)];
                            const codeRes = await fetch(chosen.download_url);
                            if (codeRes.ok) {
                                const code = await codeRes.text();
                                return {
                                    success: true,
                                    name: chosen.name,
                                    repo: repo.split('/')[1],
                                    code: code,
                                    lines: code.split('\n').length
                                };
                            }
                        }
                    } catch (e) {
                        continue;
                    }
                }
            }
            return { success: false };
        }

        // Search YouTube and get embed URL
        async function searchYouTube(query) {
            // YouTube doesn't have a free search API, so we'll use a random video approach
            const wildSearches = [
                'parkour fails compilation',
                'satisfying domino chain reaction',
                'extreme skateboard tricks',
                'funny cat compilation',
                'amazing magic tricks',
                'synthwave mix 2024'
            ];
            const searchTerm = query || wildSearches[Math.floor(Math.random() * wildSearches.length)];

            // For now, return a known working video to demonstrate
            // In production, you'd use YouTube Data API
            const demoVideos = [
                { id: 'dQw4w9WgXcQ', title: 'Rick Astley - Never Gonna Give You Up' },
                { id: 'L_jWHffIx5E', title: 'Smash Mouth - All Star' },
                { id: 'y6120QOlsfU', title: 'Darude - Sandstorm' }
            ];
            const video = demoVideos[Math.floor(Math.random() * demoVideos.length)];
            return {
                success: true,
                title: video.title,
                embedUrl: `https://www.youtube.com/embed/${video.id}?autoplay=1`,
                searchTerm: searchTerm
            };
        }

        // Generate image via Pollinations
        async function generateImage(prompt) {
            const seed = Math.floor(Math.random() * 999999999);
            const url = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=1024&height=768&seed=${seed}&nologo=true`;

            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve({ success: true, url: url, prompt: prompt });
                img.onerror = () => resolve({ success: false });
                setTimeout(() => resolve({ success: false }), 30000);
                img.src = url;
            });
        }

        // ============================================================
        // Modal Handlers
        // ============================================================

        function saveApiKeys() {
            pollinationsKey = document.getElementById('pollinationsKey').value.trim();
            githubToken = document.getElementById('githubToken').value.trim();
            weatherKey = document.getElementById('weatherKey').value.trim();
            if (pollinationsKey) localStorage.setItem('cora_pollinations_key', pollinationsKey);
            if (githubToken) localStorage.setItem('cora_github_key', githubToken);
            if (weatherKey) localStorage.setItem('cora_weather_key', weatherKey);
            document.getElementById('apiModal').classList.remove('visible');
            runBootSequence();
        }

        function skipApiKeys() {
            document.getElementById('apiModal').classList.remove('visible');
            runBootSequence();
        }

        async function retryOllama() {
            if (await checkOllama()) {
                document.getElementById('gateOverlay').classList.remove('visible');
                runBootSequence();
            } else {
                alert('Ollama still not responding. Make sure "ollama serve" is running.');
            }
        }

        // ============================================================
        // Init
        // ============================================================

        async function init() {
            renderPhases();
            document.getElementById('pollinationsKey').value = pollinationsKey;
            document.getElementById('githubToken').value = githubToken;
            document.getElementById('weatherKey').value = weatherKey;

            if (!(await checkOllama())) {
                document.getElementById('gateOverlay').classList.add('visible');
                return;
            }

            if (!pollinationsKey && !weatherKey) {
                document.getElementById('apiModal').classList.add('visible');
            } else {
                runBootSequence();
            }
        }

        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => {};
        }

        window.addEventListener('load', () => setTimeout(init, 500));
    </script>
</body>
</html>
