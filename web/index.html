<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C.O.R.A - Cognitive Operations & Reasoning Assistant</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="C.O.R.A - A Windows 11 AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, image generation, and live system monitoring. Built by Unity AI Lab.">
    <meta name="keywords" content="CORA, AI Assistant, Ollama, Voice Assistant, Unity AI Lab, Windows 11, Personal Assistant">
    <meta name="author" content="Unity AI Lab - Hackall360, Sponge, GFourteen">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://www.unityailab.com/CORA/">
    <meta property="og:title" content="C.O.R.A - Cognitive Operations & Reasoning Assistant">
    <meta property="og:description" content="AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, image generation, and live system monitoring. Open source by Unity AI Lab.">
    <meta property="og:image" content="http://www.unityailab.com/CORA/images/social-preview.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Unity AI Lab">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="http://www.unityailab.com/CORA/">
    <meta name="twitter:title" content="C.O.R.A - Cognitive Operations & Reasoning Assistant">
    <meta name="twitter:description" content="AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, and image generation. Open source by Unity AI Lab.">
    <meta name="twitter:image" content="http://www.unityailab.com/CORA/images/social-preview.png">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="images/social-preview.png">

    <style>
        :root {
            --bg-main: #0a0a0a;
            --bg-panel: #12121a;
            --bg-darker: #08080c;
            --border-color: #302050;
            --text-main: #e0e0e0;
            --text-dim: #888;
            --accent-magenta: #ff00ff;
            --accent-cyan: #00ffff;
            --ok-color: #00ff88;
            --warn-color: #ffaa00;
            --fail-color: #ff4444;
            --pending-color: #666;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: var(--bg-main);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
        }

        /* Two Column Layout - matches desktop boot_display.py */
        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
            gap: 0;
            transition: grid-template-columns 0.3s ease;
        }

        /* Fullscreen mode - console only */
        .container.fullscreen-console {
            grid-template-columns: 0 1fr;
        }
        .container.fullscreen-console .left-panel {
            display: none;
        }

        /* Fullscreen mode - status only */
        .container.fullscreen-status {
            grid-template-columns: 1fr 0;
        }
        .container.fullscreen-status .right-panel {
            display: none;
        }

        /* Toggle button */
        .toggle-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
        }
        .toggle-btn:hover {
            background: var(--accent-magenta);
            color: #000;
        }

        /* Left Panel */
        .left-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #1a0020 0%, #0d0015 100%);
            border-bottom: 2px solid var(--accent-magenta);
            padding: 15px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            color: var(--accent-magenta);
            text-shadow: 0 0 15px var(--accent-magenta);
            letter-spacing: 8px;
        }

        .header .subtitle {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 5px;
        }

        .header .version {
            font-size: 11px;
            color: var(--accent-cyan);
            margin-top: 3px;
        }

        /* Waveform - EXACT match to boot_display.py */
        .waveform-container {
            background: #0a0a0a;
            border: 1px solid #302050;
            margin: 10px;
            border-radius: 4px;
            position: relative;
        }

        .waveform-label {
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 9px;
            color: #666;
            z-index: 1;
        }

        #waveformCanvas {
            width: 100%;
            height: 100px;
            display: block;
        }

        /* Speech Text - EXACT like desktop boot_display.py */
        .speech-container {
            background: linear-gradient(180deg, #1a0020 0%, #0d0010 100%);
            border-bottom: 2px solid var(--accent-magenta);
            padding: 15px;
            min-height: 80px;
        }

        .speech-label {
            font-size: 10px;
            color: var(--accent-cyan);
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        #speechText {
            font-size: 14px;
            color: var(--accent-magenta);
            font-style: italic;
            line-height: 1.5;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
            min-height: 42px;
        }

        .tts-notice {
            font-size: 9px;
            color: #555;
            margin-top: 8px;
            font-style: normal;
        }

        .tts-notice a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        /* Progress Bar */
        .progress-container {
            padding: 10px 15px;
            background: var(--bg-darker);
            border-bottom: 1px solid var(--border-color);
        }

        .progress-bar {
            height: 6px;
            background: #1a1a2a;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-magenta), var(--accent-cyan));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 5px;
            text-align: center;
        }

        /* Phases */
        .phases-container {
            padding: 10px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            max-height: 260px;
            overflow-y: auto;
        }

        .phases-header {
            font-size: 10px;
            color: var(--accent-cyan);
            text-align: center;
            margin-bottom: 8px;
        }

        .phases-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .phase-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            padding: 3px 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
        }

        .phase-indicator {
            font-size: 10px;
            width: 14px;
            text-align: center;
        }

        .phase-indicator.pending { color: var(--pending-color); }
        .phase-indicator.running { color: var(--accent-magenta); animation: pulse 1s infinite; }
        .phase-indicator.ok { color: var(--ok-color); }
        .phase-indicator.warn { color: var(--warn-color); }
        .phase-indicator.fail { color: var(--fail-color); }

        @keyframes pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 5px var(--accent-magenta); }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stats-section {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .stats-panel {
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .stats-header {
            font-size: 10px;
            color: var(--accent-cyan);
            text-align: center;
            margin-bottom: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }

        .stat-label { color: var(--text-dim); }
        .stat-value { color: var(--ok-color); font-weight: bold; }
        .stat-value.warn { color: var(--warn-color); }
        .stat-value.na { color: var(--text-dim); font-weight: normal; }

        .web-notice {
            background: #1a1020;
            border: 1px solid #402050;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
            text-align: center;
        }

        .web-notice-title {
            color: var(--warn-color);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .web-notice a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        /* Right Panel - Log */
        .right-panel {
            background: var(--bg-main);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .log-header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            padding: 10px 15px;
            font-size: 12px;
            color: var(--accent-cyan);
        }

        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-line { margin-bottom: 2px; }
        .log-phase { color: var(--accent-magenta); font-weight: bold; margin-top: 10px; }
        .log-ok { color: var(--ok-color); }
        .log-warn { color: var(--warn-color); }
        .log-fail { color: var(--fail-color); }
        .log-info { color: var(--text-dim); }
        .log-system { color: var(--accent-cyan); }
        .log-cora { color: #ff69b4; font-weight: bold; }  /* Hot pink for CORA speech */

        /* Chat */
        .chat-section {
            display: none;
            border-top: 1px solid var(--border-color);
            padding: 15px;
            background: var(--bg-panel);
        }

        .chat-section.visible { display: block; }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        #chatInput {
            flex: 1;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            color: var(--text-main);
            font-family: inherit;
            font-size: 13px;
        }

        #chatInput:focus {
            outline: none;
            border-color: var(--accent-magenta);
        }

        #sendBtn {
            background: linear-gradient(135deg, var(--accent-magenta), #aa00aa);
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.visible { display: flex; }

        .modal {
            background: var(--bg-panel);
            border: 2px solid var(--accent-magenta);
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            color: var(--accent-magenta);
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-field {
            margin-bottom: 20px;
        }

        .modal-field label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-main);
        }

        .modal-field input {
            width: 100%;
            padding: 10px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-main);
            font-family: inherit;
        }

        .modal-field a {
            color: var(--accent-cyan);
            font-size: 12px;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-magenta);
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }

        .gate-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 999;
            align-items: center;
            justify-content: center;
        }

        .gate-overlay.visible { display: flex; }

        .gate-box {
            background: #1a0000;
            border: 2px solid var(--fail-color);
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }

        .gate-box h2 {
            color: var(--fail-color);
            margin-bottom: 15px;
        }

        .gate-box pre {
            background: #0a0a0a;
            padding: 15px;
            border-radius: 4px;
            text-align: left;
            margin: 15px 0;
            color: var(--accent-cyan);
        }

        .gate-box button {
            padding: 12px 30px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 4px;
            color: black;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <!-- Ollama Gate -->
    <div class="gate-overlay" id="gateOverlay">
        <div class="gate-box">
            <h2>[ BLOCKED ]</h2>
            <p>Ollama is not running</p>
            <pre>ollama serve</pre>
            <p style="color: var(--text-dim); font-size: 12px;">Run this in your terminal, then click Retry</p>
            <button onclick="retryOllama()">Retry Connection</button>
        </div>
    </div>

    <!-- API Key Modal -->
    <div class="modal-overlay" id="apiModal">
        <div class="modal">
            <h2>API Configuration</h2>
            <div class="modal-field">
                <label>Pollinations API Key (optional)</label>
                <input type="password" id="pollinationsKey" placeholder="pk_...">
                <a href="https://pollinations.ai" target="_blank">Get key at pollinations.ai</a>
            </div>
            <div class="modal-field">
                <label>GitHub Token (optional)</label>
                <input type="password" id="githubToken" placeholder="ghp_...">
                <a href="https://github.com/settings/tokens" target="_blank">Generate at github.com/settings/tokens</a>
            </div>
            <button class="modal-btn" onclick="saveApiKeys()">Save & Continue</button>
            <button class="modal-btn" style="background: #333; margin-top: 10px;" onclick="skipApiKeys()">Skip (Limited Features)</button>
            <button class="modal-btn" style="background: #660000; margin-top: 20px; font-size: 11px;" onclick="clearAllData()">Clear All Data</button>
        </div>
    </div>

    <!-- Toggle Button -->
    <button class="toggle-btn" id="toggleBtn" onclick="toggleView()">[ SPLIT VIEW ]</button>

    <!-- Settings Button (next to split view) -->
    <button id="settingsBtn" onclick="openSettings()" style="
        position: fixed; top: 10px; right: 130px; z-index: 500;
        background: #333; border: 1px solid #666; color: #999;
        padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;
    ">[ SETTINGS ]</button>

    <!-- Open Console Button -->
    <button id="consoleBtn" onclick="openConsoleWindow()" style="
        position: fixed; top: 10px; right: 250px; z-index: 500;
        background: #333; border: 1px solid #666; color: #999;
        padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;
    ">[ CONSOLE ]</button>

    <!-- Main Container -->
    <div class="container" id="mainContainer">
        <div class="left-panel">
            <div class="header">
                <h1>C.O.R.A</h1>
                <div class="subtitle">Cognitive Operations & Reasoning Assistant</div>
                <div class="version">v2.4.0 - Unity AI Lab</div>
            </div>

            <div class="waveform-container">
                <div class="waveform-label">▶ VOICE SYNTHESIS</div>
                <canvas id="waveformCanvas"></canvas>
            </div>

            <div class="speech-container">
                <div class="speech-label">▶ CORA SPEAKING</div>
                <div id="speechText">"Initializing..."</div>
                <div class="tts-notice" id="ttsNotice">Loading Kokoro neural voice (af_bella)...</div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Booting...</div>
            </div>

            <div class="phases-container">
                <div class="phases-header">── BOOT PHASES ──</div>
                <div class="phases-grid" id="phasesSection"></div>
            </div>

            <div class="stats-section">
                <div class="stats-panel">
                    <div class="stats-header">── LIVE SYSTEM STATS ──</div>
                    <div class="stats-grid">
                        <div class="stat-item"><span class="stat-label">CPU:</span><span class="stat-value" id="statCpu">--</span></div>
                        <div class="stat-item"><span class="stat-label">MEM:</span><span class="stat-value" id="statMem">--</span></div>
                        <div class="stat-item"><span class="stat-label">DISK:</span><span class="stat-value" id="statDisk">--</span></div>
                        <div class="stat-item"><span class="stat-label">GPU:</span><span class="stat-value" id="statGpu">--</span></div>
                        <div class="stat-item"><span class="stat-label">VRAM:</span><span class="stat-value" id="statVram">--</span></div>
                        <div class="stat-item"><span class="stat-label">NET:</span><span class="stat-value" id="statNet">--</span></div>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stats-header">── SERVICE STATUS ──</div>
                    <div class="stats-grid">
                        <div class="stat-item"><span class="stat-label">Ollama:</span><span class="stat-value" id="statOllama">--</span></div>
                        <div class="stat-item"><span class="stat-label">Pollinations:</span><span class="stat-value" id="statPollinations">--</span></div>
                        <div class="stat-item"><span class="stat-label">Weather:</span><span class="stat-value" id="statWeather">--</span></div>
                        <div class="stat-item"><span class="stat-label">Boot:</span><span class="stat-value" id="statBootTime">--</span></div>
                    </div>
                </div>

                <div class="web-notice">
                    <div class="web-notice-title">WEB VERSION</div>
                    <div>Full C.O.R.A running in your browser!<br>
                    <a href="https://github.com/Unity-Lab-AI/CORA.git" target="_blank">Get source on GitHub</a></div>
                </div>
            </div>

            <div class="chat-section" id="chatSection">
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Talk to CORA...">
                    <button id="sendBtn" onclick="sendChat()">Send</button>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="log-header">[ BOOT CONSOLE ]</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>

    <script>
        // ============================================================
        // C.O.R.A Web Interface - Full Boot Sequence with TTS
        // Matches desktop boot_sequence.py exactly
        // ============================================================

        // EXACT match to desktop boot_sequence.py phases (18 total)
        const PHASES = [
            { id: 'waveform', name: '0.8 Waveform Init', status: 'pending' },
            { id: 'about', name: '0.9 About CORA', status: 'pending' },
            { id: 'voice', name: '1.0 Voice Synthesis', status: 'pending' },
            { id: 'ai_engine', name: '2.0 AI Engine', status: 'pending' },
            { id: 'ai_models', name: '2.1 AI Models', status: 'pending' },
            { id: 'hardware', name: '3.0 Hardware Check', status: 'pending' },
            { id: 'camera', name: '3.1 Camera Feed', status: 'pending' },
            { id: 'tools', name: '4.0 Core Tools', status: 'pending' },
            { id: 'code_import', name: '4.1 Code Import', status: 'pending' },
            { id: 'youtube', name: '4.2 YouTube Test', status: 'pending' },
            { id: 'modals', name: '4.3 Modal Windows', status: 'pending' },
            { id: 'voice_sys', name: '5.0 Voice Systems', status: 'pending' },
            { id: 'external', name: '6.0 External APIs', status: 'pending' },
            { id: 'audio', name: '6.1 Audio Test', status: 'pending' },
            { id: 'news', name: '7.0 News Headlines', status: 'pending' },
            { id: 'vision', name: '8.0 Vision Test', status: 'pending' },
            { id: 'imagegen', name: '9.0 Image Gen', status: 'pending' },
            { id: 'final', name: '10.0 Final Check', status: 'pending' }
        ];

        let bootStartTime = null;
        let waveformActive = false;
        let waveformCtx = null;
        let animationId = null;

        let pollinationsKey = localStorage.getItem('cora_pollinations_key') || '';
        let githubToken = localStorage.getItem('cora_github_key') || '';

        // ============================================================
        // KOKORO TTS - Neural voice (same as desktop af_bella)
        // Falls back to Web Speech API if Kokoro fails
        // ============================================================

        let kokoroWorker = null;
        let kokoroReady = false;
        let kokoroLoading = false;
        let audioContext = null;
        let pendingCallbacks = {};
        let messageId = 0;
        let useFallbackTTS = false;

        async function initKokoro(progressCallback) {
            if (kokoroReady) return true;
            if (kokoroLoading) return false;

            kokoroLoading = true;

            try {
                // Create audio context (must happen on user interaction for some browsers)
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Create web worker
                kokoroWorker = new Worker('kokoro-worker.js', { type: 'module' });

                return new Promise((resolve) => {
                    const initId = ++messageId;

                    kokoroWorker.onmessage = (e) => {
                        const { type, id, data, error } = e.data;

                        if (type === 'progress' && id === initId) {
                            if (progressCallback) progressCallback(data.message, data.progress);
                        }
                        else if (type === 'initComplete' && id === initId) {
                            kokoroReady = true;
                            kokoroLoading = false;
                            resolve(true);
                        }
                        else if (type === 'error' && id === initId) {
                            console.error('Kokoro init error:', error);
                            kokoroLoading = false;
                            resolve(false);
                        }
                        else if (type === 'audioReady') {
                            handleAudioReady(id, data);
                        }
                        else if (type === 'generating') {
                            // Audio is being generated, keep waveform active
                        }
                    };

                    kokoroWorker.postMessage({ type: 'init', id: initId, data: {} });
                });

            } catch (e) {
                console.error('Failed to init Kokoro:', e);
                kokoroLoading = false;
                return false;
            }
        }

        function handleAudioReady(id, data) {
            if (!pendingCallbacks[id]) return;

            const { resolve, startTime } = pendingCallbacks[id];
            delete pendingCallbacks[id];

            try {
                // Convert ArrayBuffer back to Float32Array
                const float32Audio = new Float32Array(data.audio);
                const sampleRate = data.sampleRate || 24000;

                // Feed audio samples to waveform for visualization
                // Downsample to ~100 samples for waveform display
                const step = Math.max(1, Math.floor(float32Audio.length / 100));
                const waveformSamples = [];
                for (let i = 0; i < float32Audio.length; i += step) {
                    waveformSamples.push(float32Audio[i]);
                }
                feedAudioChunk(waveformSamples);

                // Create audio buffer and play it
                const audioBuffer = audioContext.createBuffer(1, float32Audio.length, sampleRate);
                audioBuffer.copyToChannel(float32Audio, 0);

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                // Create analyser to feed real-time audio to waveform
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                const dataArray = new Float32Array(analyser.frequencyBinCount);

                // Update waveform while playing
                let animFrame;
                const updateWaveform = () => {
                    analyser.getFloatTimeDomainData(dataArray);
                    feedAudioChunk(Array.from(dataArray));
                    if (audio_is_active) {
                        animFrame = requestAnimationFrame(updateWaveform);
                    }
                };

                source.onended = () => {
                    cancelAnimationFrame(animFrame);
                    stopWaveform();
                    resolve();
                };

                startWaveform();
                source.start();
                updateWaveform();

            } catch (e) {
                console.error('Audio playback error:', e);
                stopWaveform();
                resolve();
            }
        }

        function speak(text, callback) {
            // Show speech text with quotes like desktop boot_display.py
            document.getElementById('speechText').textContent = `"${text}"`;

            // Log CORA speech in hot pink to stand out
            log(`CORA: "${text}"`, 'cora');

            if (kokoroReady && !useFallbackTTS) {
                // Use Kokoro neural TTS
                const id = ++messageId;
                pendingCallbacks[id] = {
                    resolve: callback || (() => {}),
                    startTime: Date.now()
                };

                startWaveform();
                kokoroWorker.postMessage({
                    type: 'generate',
                    id,
                    data: { text, voice: 'af_bella', speed: 1.0 }
                });
            } else {
                // Fallback to Web Speech API
                if ('speechSynthesis' in window) {
                    const synth = window.speechSynthesis;
                    synth.cancel();

                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.0;
                    utterance.pitch = 1.1;

                    const voices = synth.getVoices();
                    const femaleVoice = voices.find(v =>
                        v.name.includes('Zira') || v.name.includes('Samantha') ||
                        v.name.toLowerCase().includes('female')
                    ) || voices[0];
                    if (femaleVoice) utterance.voice = femaleVoice;

                    utterance.onstart = () => startWaveform();
                    utterance.onend = () => { stopWaveform(); if (callback) callback(); };
                    utterance.onerror = () => { stopWaveform(); if (callback) callback(); };

                    synth.speak(utterance);
                } else {
                    if (callback) setTimeout(callback, 100);
                }
            }
        }

        function speakAndWait(text) {
            return new Promise(resolve => speak(text, resolve));
        }

        // ============================================================
        // WAVEFORM - EXACT 1:1 PORT FROM boot_display.py AudioWaveform
        // Lines 127-384 of boot_display.py
        // THIS RUNS FOREVER - NEVER STOPS
        // ============================================================

        // EXACT values from boot_display.py lines 140-146
        const NUM_POINTS = 100;  // self.num_points = 100
        let wave_points = new Array(NUM_POINTS).fill(0.0);  // self.wave_points
        let sample_buffer = new Array(NUM_POINTS).fill(0.0);  // self.sample_buffer

        // Audio state - like _audio_buffer_singleton in desktop
        let audio_chunk = null;  // Current audio samples
        let audio_chunk_time = null;  // When chunk was received
        let audio_is_active = false;  // Is TTS currently speaking

        function initWaveform() {
            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            waveformCtx = canvas.getContext('2d');
            waveformCtx.scale(2, 2);

            // Start animation - RUNS FOREVER, NEVER STOPS (line 212)
            _animate();
        }

        // These just set the audio state - animation NEVER stops
        function startWaveform() {
            audio_is_active = true;
            audio_chunk_time = Date.now();
        }

        function stopWaveform() {
            audio_is_active = false;
        }

        // Feed actual audio samples to waveform (like _audio_buffer_singleton)
        function feedAudioChunk(samples) {
            audio_chunk = samples;
            audio_chunk_time = Date.now();
        }

        function _animate() {
            // EXACT port of boot_display.py _animate() lines 205-322
            // "This runs FOREVER once started - never stops."

            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            // Check for audio - like lines 219-236
            let has_audio = false;
            let chunk = null;

            if (audio_chunk_time !== null) {
                const time_since_chunk = Date.now() - audio_chunk_time;
                // Accept chunks up to 300ms old (line 231)
                if (audio_chunk !== null && time_since_chunk < 300 && audio_is_active) {
                    has_audio = true;
                    chunk = audio_chunk;
                }
            }

            if (has_audio && chunk !== null) {
                // Process audio chunk - lines 240-305
                const chunk_len = chunk.length;
                const samples_to_add = Math.min(20, Math.floor(NUM_POINTS / 5));  // line 254

                if (chunk_len >= samples_to_add) {
                    // Downsample - line 258-259
                    const new_samples = [];
                    for (let i = 0; i < samples_to_add; i++) {
                        const idx = Math.floor(i * chunk_len / samples_to_add);
                        new_samples.push(chunk[idx]);
                    }

                    // Find peak for adaptive scaling - lines 263-270
                    let chunk_peak = 0;
                    for (let i = 0; i < chunk.length; i++) {
                        chunk_peak = Math.max(chunk_peak, Math.abs(chunk[i]));
                    }
                    let scale_factor = 20.0;
                    if (chunk_peak > 0.001) {
                        scale_factor = Math.min(0.95 / chunk_peak, 40.0);
                    }

                    // Scale and clamp - lines 270-273
                    for (let i = 0; i < new_samples.length; i++) {
                        new_samples[i] = Math.max(-1.0, Math.min(1.0, new_samples[i] * scale_factor));
                    }

                    // Shift buffer left, add new on right - line 276
                    sample_buffer = sample_buffer.slice(samples_to_add).concat(new_samples);
                }

                // Smooth transition - lines 302-305
                for (let i = 0; i < NUM_POINTS; i++) {
                    wave_points[i] = wave_points[i] * 0.3 + sample_buffer[i] * 0.7;
                }

            } else {
                // No audio - DECAY toward zero (lines 312-316)
                // Desktop behavior: NO fake waves, only real audio or decay
                const decay = 0.92;
                for (let i = 0; i < NUM_POINTS; i++) {
                    wave_points[i] *= decay;
                    sample_buffer[i] *= decay;
                }
            }

            // Draw the wave - line 319
            _draw_wave(width, height);

            // Schedule next frame - 25ms = ~40 FPS - line 322
            setTimeout(() => requestAnimationFrame(_animate), 25);
        }

        function _draw_wave(width, height) {
            // Symmetric waveform - expands OUT from center, collapses TO center at silence
            const ctx = waveformCtx;
            const center_y = height / 2;
            const max_amp = (height / 2) - 5;

            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Center reference line (dim)
            ctx.strokeStyle = '#201030';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, center_y);
            ctx.lineTo(width, center_y);
            ctx.stroke();

            // Build coordinates for top and bottom curves
            // Amplitude expands symmetrically from center
            const step = width / (NUM_POINTS - 1);
            const topCoords = [];
            const bottomCoords = [];

            for (let i = 0; i < NUM_POINTS; i++) {
                const x = i * step;
                const amp = Math.abs(wave_points[i]) * max_amp;
                topCoords.push([x, center_y - amp]);      // Above center
                bottomCoords.push([x, center_y + amp]);   // Below center (mirror)
            }

            if (topCoords.length >= 4) {
                // 4 glow layers
                const layers = [
                    { color: '#400060', width: 8 },   // Outer glow
                    { color: '#8000a0', width: 5 },   // Mid glow
                    { color: '#ff40ff', width: 3 },   // Main wave
                    { color: '#ffc0ff', width: 1 }    // Bright core
                ];

                // Draw each layer as a closed shape (top curve + bottom curve mirrored)
                layers.forEach(layer => {
                    ctx.strokeStyle = layer.color;
                    ctx.lineWidth = layer.width;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Draw top curve (above center)
                    ctx.beginPath();
                    ctx.moveTo(topCoords[0][0], topCoords[0][1]);
                    for (let i = 1; i < topCoords.length - 1; i++) {
                        const xc = (topCoords[i][0] + topCoords[i + 1][0]) / 2;
                        const yc = (topCoords[i][1] + topCoords[i + 1][1]) / 2;
                        ctx.quadraticCurveTo(topCoords[i][0], topCoords[i][1], xc, yc);
                    }
                    ctx.lineTo(topCoords[topCoords.length - 1][0], topCoords[topCoords.length - 1][1]);
                    ctx.stroke();

                    // Draw bottom curve (below center - mirror)
                    ctx.beginPath();
                    ctx.moveTo(bottomCoords[0][0], bottomCoords[0][1]);
                    for (let i = 1; i < bottomCoords.length - 1; i++) {
                        const xc = (bottomCoords[i][0] + bottomCoords[i + 1][0]) / 2;
                        const yc = (bottomCoords[i][1] + bottomCoords[i + 1][1]) / 2;
                        ctx.quadraticCurveTo(bottomCoords[i][0], bottomCoords[i][1], xc, yc);
                    }
                    ctx.lineTo(bottomCoords[bottomCoords.length - 1][0], bottomCoords[bottomCoords.length - 1][1]);
                    ctx.stroke();
                });
            }
        }

        // ============================================================
        // Logging & Phases
        // ============================================================

        // Store log history for console window sync
        const logHistory = [];
        let consoleWindow = null;

        // Function to send logs to console window
        function sendToConsole(data) {
            // Save to localStorage (works for file://)
            localStorage.setItem('cora_log_history', JSON.stringify(logHistory));
            localStorage.setItem('cora_console_log', JSON.stringify(data));

            // Also try postMessage if console window exists
            if (consoleWindow && !consoleWindow.closed) {
                try {
                    consoleWindow.postMessage(data, '*');
                } catch (e) {}
            }
        }

        // Listen for messages from console window
        window.addEventListener('message', (e) => {
            if (e.data.type === 'ping') {
                e.source.postMessage({ type: 'pong' }, '*');
            } else if (e.data.type === 'requestHistory') {
                e.source.postMessage({ type: 'history', logs: logHistory }, '*');
            }
        });

        function log(text, type = 'info') {
            const container = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            const line = document.createElement('div');
            line.className = `log-line log-${type}`;

            let fullText;
            if (type === 'phase') {
                line.style.marginTop = '10px';
                fullText = `[${timestamp}] ═══════════════ ${text} ═══════════════`;
            } else {
                const prefix = type === 'ok' ? '✓' : type === 'warn' ? '⚠' : type === 'fail' ? '✗' : '';
                fullText = `[${timestamp}] ${prefix ? prefix + ' ' : ''}${text}`;
            }
            line.textContent = fullText;

            container.appendChild(line);
            container.scrollTop = container.scrollHeight;

            // Store in history and send to console window
            logHistory.push({ text: fullText, logType: type });
            sendToConsole({ type: 'log', text: fullText, logType: type });
        }

        function renderPhases() {
            const container = document.getElementById('phasesSection');
            container.innerHTML = '';
            PHASES.forEach(phase => {
                const item = document.createElement('div');
                item.className = 'phase-item';
                let indicator = '○';
                if (phase.status === 'running') indicator = '◐';
                else if (['ok', 'warn', 'fail'].includes(phase.status)) indicator = '●';
                item.innerHTML = `<span class="phase-indicator ${phase.status}">${indicator}</span><span>${phase.name}</span>`;
                container.appendChild(item);
            });
        }

        function setPhase(id, status) {
            const phase = PHASES.find(p => p.id === id);
            if (phase) { phase.status = status; renderPhases(); }
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        // ============================================================
        // Dynamic Modal System (matches desktop tkinter popups)
        // ============================================================

        function createDynamicModal(title, width = 800, height = 600) {
            // Remove any existing dynamic modal
            const existing = document.getElementById('dynamicModal');
            if (existing) existing.remove();

            const overlay = document.createElement('div');
            overlay.id = 'dynamicModal';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;

            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #1a1a2e; border: 2px solid #ff00ff;
                border-radius: 8px; width: ${width}px; max-width: 95vw;
                max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;
            `;

            const header = document.createElement('div');
            header.style.cssText = `
                background: linear-gradient(135deg, #2d0040 0%, #1a0020 100%);
                padding: 15px 20px; border-bottom: 1px solid #ff00ff;
                display: flex; justify-content: space-between; align-items: center;
            `;
            header.innerHTML = `<span style="color: #ff00ff; font-weight: bold; font-size: 14px;">${title}</span>`;

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'X';
            closeBtn.style.cssText = `
                background: #ff4444; border: none; color: white; width: 30px; height: 30px;
                border-radius: 4px; cursor: pointer; font-weight: bold;
            `;
            closeBtn.onclick = () => overlay.remove();
            header.appendChild(closeBtn);

            const content = document.createElement('div');
            content.style.cssText = 'flex: 1; overflow: auto; padding: 15px;';

            modal.appendChild(header);
            modal.appendChild(content);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            return { overlay, modal, content, close: () => overlay.remove() };
        }

        function showCodeModal(code, filename, language = 'python') {
            const { content, close } = createDynamicModal(`CORA - Code Import: ${filename}`, 900, 600);
            content.innerHTML = `
                <div style="color: #00ff88; margin-bottom: 10px; font-size: 12px;">
                    Source: GitHub API | File: ${filename}
                </div>
                <pre style="background: #0d0d1a; padding: 15px; border-radius: 4px;
                    overflow: auto; max-height: 450px; color: #e0e0e0; font-size: 12px;
                    white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(code)}</pre>
            `;
            return { close };
        }

        function showImageModal(imageUrl, title) {
            const { content, close } = createDynamicModal(title, 1000, 700);
            content.style.padding = '0';
            content.innerHTML = `
                <img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: contain; background: black;">
            `;
            return { close };
        }

        function showVideoModal(videoId, title) {
            const { content, close } = createDynamicModal(title, 800, 500);
            content.style.padding = '0';
            content.innerHTML = `
                <iframe width="100%" height="100%" src="https://www.youtube.com/embed/${videoId}?autoplay=1"
                    frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
            `;
            return { close };
        }

        function showQuoteModal(quote) {
            const { content, close } = createDynamicModal('CORA - Modal Test', 500, 300);
            content.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div style="color: #00ff88; font-size: 16px; margin-bottom: 20px;">Modal Window Test</div>
                    <div style="color: #ffffff; font-style: italic; font-size: 14px; margin-bottom: 20px;">"${quote}"</div>
                    <div style="color: #888; font-size: 12px;">
                        Modal Types Available:<br>
                        - Message popups<br>
                        - Code viewer<br>
                        - Image viewer<br>
                        - Video player
                    </div>
                </div>
            `;
            return { close };
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================================
        // Stats Server (localhost:11435) - Real GPU/CPU/RAM from host
        // ============================================================

        const STATS_URL = 'http://localhost:11435';
        let statsServerAvailable = false;

        async function fetchSystemStats() {
            try {
                const res = await fetch(`${STATS_URL}/stats`, { method: 'GET' });
                if (res.ok) {
                    const stats = await res.json();
                    statsServerAvailable = true;
                    updateStatsDisplay(stats);
                    return stats;
                }
            } catch (e) {
                statsServerAvailable = false;
            }
            return null;
        }

        function updateStatsDisplay(stats) {
            if (!stats) return;

            // CPU
            document.getElementById('statCpu').textContent = `${Math.round(stats.cpu.percent)}%`;
            document.getElementById('statCpu').className = 'stat-value';

            // Memory
            document.getElementById('statMem').textContent = `${Math.round(stats.memory.percent)}%`;
            document.getElementById('statMem').className = 'stat-value';

            // Disk
            document.getElementById('statDisk').textContent = `${Math.round(stats.disk.percent)}%`;
            document.getElementById('statDisk').className = 'stat-value';

            // GPU
            if (stats.gpu && stats.gpu.available) {
                document.getElementById('statGpu').textContent = `${stats.gpu.utilization}%`;
                document.getElementById('statGpu').className = 'stat-value';
                // VRAM
                const vramPercent = Math.round((stats.gpu.memory_used / stats.gpu.memory_total) * 100);
                document.getElementById('statVram').textContent = `${vramPercent}%`;
                document.getElementById('statVram').className = 'stat-value';
            } else {
                document.getElementById('statGpu').textContent = 'N/A';
                document.getElementById('statGpu').className = 'stat-value na';
                document.getElementById('statVram').textContent = 'N/A';
                document.getElementById('statVram').className = 'stat-value na';
            }

            // Network
            document.getElementById('statNet').textContent = 'Online';
            document.getElementById('statNet').className = 'stat-value';
        }

        // Start polling stats every second
        let statsInterval = null;
        function startStatsPolling() {
            if (statsInterval) return;
            statsInterval = setInterval(fetchSystemStats, 1000);
            fetchSystemStats(); // Initial fetch
        }

        function stopStatsPolling() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        // ============================================================
        // API Checks
        // ============================================================

        async function checkOllama() {
            try {
                const r = await fetch('http://localhost:11434/api/tags', { method: 'GET' });
                return r.ok;
            } catch { return false; }
        }

        async function getOllamaModels() {
            try {
                const r = await fetch('http://localhost:11434/api/tags');
                const d = await r.json();
                return d.models || [];
            } catch { return []; }
        }

        async function checkPollinations() {
            try {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve(true);
                    img.onerror = () => resolve(false);
                    setTimeout(() => resolve(false), 5000);
                    img.src = 'https://image.pollinations.ai/prompt/test?width=64&height=64&nologo=true';
                });
            } catch { return false; }
        }

        // Store location coords for reuse
        let cachedCoords = null;

        async function requestLocationPermission() {
            // Request location with generous timeout
            return new Promise((resolve) => {
                log('Requesting location permission...', 'info');
                log('Please click "Allow" when browser asks for location', 'system');

                // Try up to 2 times
                let attempts = 0;
                const maxAttempts = 2;

                function tryGetLocation() {
                    attempts++;
                    navigator.geolocation.getCurrentPosition(
                        (pos) => {
                            cachedCoords = pos.coords;
                            log(`Location acquired on attempt ${attempts}`, 'ok');
                            resolve(pos.coords);
                        },
                        (err) => {
                            if (err.code === 1) {
                                log('Location permission denied by user', 'warn');
                                resolve(null);  // User denied, don't retry
                            } else if (err.code === 2) {
                                log('Location unavailable', 'warn');
                                resolve(null);
                            } else if (err.code === 3) {
                                if (attempts < maxAttempts) {
                                    log(`Location timed out, retrying (${attempts}/${maxAttempts})...`, 'warn');
                                    setTimeout(tryGetLocation, 1000);
                                } else {
                                    log('Location request timed out after retries', 'warn');
                                    resolve(null);
                                }
                            } else {
                                resolve(null);
                            }
                        },
                        {
                            timeout: 60000,           // 60 sec timeout
                            enableHighAccuracy: false,
                            maximumAge: 300000        // Accept cached location up to 5 min old
                        }
                    );
                }

                tryGetLocation();
            });
        }

        async function getLocation() {
            try {
                let coords = cachedCoords;
                if (!coords) {
                    coords = await requestLocationPermission();
                }

                // If browser geolocation failed, try IP-based fallback
                if (!coords) {
                    log('Trying IP-based location fallback...', 'info');
                    try {
                        const ipRes = await fetch('https://ipapi.co/json/');
                        if (ipRes.ok) {
                            const ipData = await ipRes.json();
                            if (ipData.latitude && ipData.longitude) {
                                log('Got location from IP', 'ok');
                                cachedCoords = { latitude: ipData.latitude, longitude: ipData.longitude };
                                return {
                                    city: ipData.city || '',
                                    state: ipData.region || '',
                                    country: ipData.country_name || '',
                                    lat: ipData.latitude,
                                    lon: ipData.longitude
                                };
                            }
                        }
                    } catch (ipErr) {
                        log('IP location fallback failed', 'warn');
                    }
                    return null;
                }

                const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${coords.latitude}&lon=${coords.longitude}&format=json`);
                if (res.ok) {
                    const d = await res.json();
                    return {
                        city: d.address?.city || d.address?.town || d.address?.village || '',
                        state: d.address?.state || '',
                        country: d.address?.country || '',
                        lat: coords.latitude,
                        lon: coords.longitude
                    };
                }
            } catch (e) {
                log(`Location error: ${e.message}`, 'warn');
            }
            return null;
        }

        async function getWeather(location = '') {
            // Uses wttr.in - FREE, no API key needed (same as desktop app)
            try {
                // wttr.in format: %t=temp, %C=condition, %h=humidity, %w=wind, %f=feels like
                const url = `https://wttr.in/${encodeURIComponent(location)}?format=%t|%C|%h|%w|%f`;
                const res = await fetch(url, {
                    headers: { 'User-Agent': 'CORA/2.0' }
                });
                if (res.ok) {
                    const text = await res.text();
                    const parts = text.trim().split('|');
                    if (parts.length >= 5) {
                        return {
                            temp: parts[0].trim(),
                            conditions: parts[1].trim(),
                            humidity: parts[2].trim(),
                            wind: parts[3].trim(),
                            feels_like: parts[4].trim(),
                            success: true
                        };
                    }
                }
            } catch (e) {
                log(`Weather error: ${e.message}`, 'warn');
            }
            return { success: false };
        }

        async function getNews() {
            try {
                const res = await fetch('https://api.rss2json.com/v1/api.json?rss_url=https://news.google.com/rss?hl=en-US');
                if (res.ok) {
                    const d = await res.json();
                    return d.items?.slice(0, 5).map(i => i.title) || [];
                }
            } catch {}
            return [];
        }

        // ============================================================
        // Wake Word Detection - "Hey CORA" using Web Speech API
        // ============================================================

        let wakeWordRecognition = null;
        let wakeWordActive = false;

        function initWakeWord() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return;

            wakeWordRecognition = new SpeechRecognition();
            wakeWordRecognition.continuous = true;
            wakeWordRecognition.interimResults = true;
            wakeWordRecognition.lang = 'en-US';

            wakeWordRecognition.onresult = (event) => {
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript.toLowerCase().trim();

                    // Check for wake words
                    if (transcript.includes('hey cora') ||
                        transcript.includes('hey kora') ||
                        transcript.includes('hey corra') ||
                        transcript.includes('okay cora') ||
                        (transcript.includes('cora') && transcript.length < 15)) {

                        if (event.results[i].isFinal) {
                            onWakeWordDetected();
                        }
                    }
                }
            };

            wakeWordRecognition.onerror = (event) => {
                if (event.error !== 'no-speech' && event.error !== 'aborted') {
                    console.log('Wake word error:', event.error);
                }
                // Restart on error (except if manually stopped)
                if (wakeWordActive) {
                    setTimeout(() => startWakeWordListening(), 1000);
                }
            };

            wakeWordRecognition.onend = () => {
                // Auto-restart when it ends (continuous listening)
                if (wakeWordActive) {
                    setTimeout(() => startWakeWordListening(), 100);
                }
            };

            startWakeWordListening();
        }

        function startWakeWordListening() {
            if (wakeWordRecognition && !wakeWordActive) {
                try {
                    wakeWordActive = true;
                    wakeWordRecognition.start();
                } catch (e) {
                    // Already started
                }
            }
        }

        function stopWakeWordListening() {
            wakeWordActive = false;
            if (wakeWordRecognition) {
                try {
                    wakeWordRecognition.stop();
                } catch (e) {}
            }
        }

        function onWakeWordDetected() {
            log('Wake word detected! Listening...', 'ok');
            speakAndWait("Yes? I'm listening.").then(() => {
                // Focus the chat input so user can type or speak
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.focus();
                    chatInput.placeholder = "I'm listening... type or speak";
                }
            });
        }

        // ============================================================
        // Boot Sequence - EXACT match to desktop boot_sequence.py
        // ============================================================

        let ttsEnabled = true;  // Track if TTS is working

        async function runBootSequence() {
            bootStartTime = Date.now();

            // ================================================================
            // PHASE 0.8: WAVEFORM INITIALIZATION
            // ================================================================
            setPhase('waveform', 'running');
            log('PHASE 0.8: WAVEFORM VISUAL', 'phase');
            updateProgress(3, 'Initializing waveform...');
            initWaveform();
            log('AudioWaveform module loaded', 'ok');
            log('Boot display exists', 'ok');
            log('Waveform widget created', 'ok');
            log('Audio buffer initialized', 'ok');
            log('All waveform checks passed', 'ok');
            setPhase('waveform', 'ok');
            await sleep(200);

            // ================================================================
            // PHASE 0.9: ABOUT CORA (Introduction)
            // ================================================================
            setPhase('about', 'running');
            log('PHASE 0.9: ABOUT CORA', 'phase');
            updateProgress(6, 'Loading identity...');
            log('═══════════════════════════════════════════════', 'system');
            log('    C.O.R.A - Cognitive Operations & Reasoning Assistant', 'system');
            log('═══════════════════════════════════════════════', 'system');
            log('Version: 2.4.0', 'info');
            log('Created by: Unity AI Lab', 'info');
            log('Developers: Hackall360, Sponge, GFourteen', 'info');
            log('Website: https://www.unityailab.com', 'info');
            log('GitHub: https://github.com/Unity-Lab-AI', 'info');
            setPhase('about', 'ok');
            await sleep(200);

            // ================================================================
            // PHASE 1.0: VOICE SYNTHESIS (Kokoro TTS)
            // ================================================================
            setPhase('voice', 'running');
            log('PHASE 1.0: VOICE SYNTHESIS', 'phase');
            updateProgress(8, 'Loading Kokoro TTS...');
            log('Loading Kokoro TTS engine...', 'info');
            log('Initializing Kokoro-82M neural TTS model...', 'info');
            log('Voice: af_bella (CORA\'s voice)', 'info');

            const kokoroOk = await initKokoro((msg, progress) => {
                log(msg, 'info');
                updateProgress(8 + (progress * 0.07), msg);
            });

            if (kokoroOk) {
                log('Kokoro TTS initialized successfully', 'ok');
                log('Voice: af_bella (sexy voice)', 'ok');
                document.getElementById('ttsNotice').textContent = 'Kokoro TTS (af_bella) - Neural voice active';
                document.getElementById('ttsNotice').style.color = '#00ff88';
                setPhase('voice', 'ok');
                ttsEnabled = true;
                updateProgress(15, 'Neural voice online');
                await speakAndWait("Voice synthesis online. Kokoro TTS loaded and ready.");
                await speakAndWait("Hey, I'm CORA. That stands for Cognitive Operations and Reasoning Assistant. Version 2.4.0. Made by Hackall360, Sponge, and GFourteen over at Unity AI Lab. I've got voice, vision, and plenty of attitude. Let's get this boot going.");
            } else {
                log('Kokoro failed - using browser TTS', 'warn');
                document.getElementById('ttsNotice').textContent = 'Browser TTS (fallback mode)';
                document.getElementById('ttsNotice').style.color = '#ffaa00';
                useFallbackTTS = true;
                ttsEnabled = true;
                setPhase('voice', 'warn');
                updateProgress(15, 'Fallback voice');
                await speakAndWait("Voice synthesis online. Using browser fallback. Hey, I'm CORA. Let's do this.");
            }

            // ================================================================
            // PHASE 2.0: AI ENGINE (Ollama)
            // ================================================================
            setPhase('ai_engine', 'running');
            log('PHASE 2.0: AI ENGINE', 'phase');
            updateProgress(20, 'Checking Ollama...');
            log('Checking Ollama connection...', 'info');
            const ollamaOk = await checkOllama();
            if (ollamaOk) {
                log('AI Engine online - Ollama', 'ok');
                document.getElementById('statOllama').textContent = 'Online';
                document.getElementById('statOllama').className = 'stat-value';
                setPhase('ai_engine', 'ok');
                await speakAndWait("AI engine online. Ollama is running.");
            } else {
                log('AI Engine not responding', 'fail');
                document.getElementById('statOllama').textContent = 'Offline';
                document.getElementById('statOllama').className = 'stat-value fail';
                setPhase('ai_engine', 'fail');
                document.getElementById('gateOverlay').classList.add('visible');
                return;  // Blocked - can't continue without AI
            }

            // ================================================================
            // PHASE 2.1: AI MODELS CHECK
            // ================================================================
            setPhase('ai_models', 'running');
            log('PHASE 2.1: AI MODELS CHECK', 'phase');
            updateProgress(25, 'Checking models...');
            const models = await getOllamaModels();
            log(`Found ${models.length} models installed`, 'info');
            if (models.length > 0) {
                models.slice(0, 5).forEach(m => log(`  - ${m.name}`, 'ok'));
                setPhase('ai_models', 'ok');
                await speakAndWait(`${models.length} AI models loaded and ready.`);
            } else {
                log('No models found - need to pull some', 'warn');
                setPhase('ai_models', 'warn');
                await speakAndWait("No models found. You'll need to pull some.");
            }

            // ================================================================
            // PHASE 3.0: HARDWARE CHECK - Fetch from local stats server
            // ================================================================
            setPhase('hardware', 'running');
            log('PHASE 3.0: HARDWARE CHECK', 'phase');
            updateProgress(30, 'Checking hardware...');

            // Try to fetch real stats from localhost:11435
            log('Connecting to stats server...', 'info');
            const stats = await fetchSystemStats();

            if (stats) {
                log(`CPU Usage: ${Math.round(stats.cpu.percent)}%`, 'ok');
                log(`Memory: ${Math.round(stats.memory.percent)}% (${stats.memory.used_gb}GB / ${stats.memory.total_gb}GB)`, 'ok');
                log(`Disk: ${Math.round(stats.disk.percent)}%`, 'ok');

                if (stats.gpu && stats.gpu.available) {
                    log(`GPU: ${stats.gpu.name}`, 'ok');
                    log(`GPU Load: ${stats.gpu.utilization}%`, 'ok');
                    log(`VRAM: ${stats.gpu.memory_used}MB / ${stats.gpu.memory_total}MB`, 'ok');
                    log(`GPU Temp: ${stats.gpu.temperature}°C`, 'ok');
                } else {
                    log('GPU: No NVIDIA GPU detected', 'warn');
                }

                log('Network: Connected', 'ok');
                setPhase('hardware', 'ok');

                // Start polling for live updates
                startStatsPolling();

                const gpuMsg = stats.gpu?.available ? `GPU at ${stats.gpu.utilization}%` : 'no GPU detected';
                await speakAndWait(`Hardware check complete. CPU at ${Math.round(stats.cpu.percent)}%, ${gpuMsg}.`);
            } else {
                // Stats server not running - fallback to basic info
                log('Stats server not running (start with: python services/stats_server.py)', 'warn');
                log('Network: ' + (navigator.onLine ? 'Connected' : 'Disconnected'), navigator.onLine ? 'ok' : 'warn');
                document.getElementById('statNet').textContent = navigator.onLine ? 'Online' : 'Offline';
                setPhase('hardware', 'warn');
                await speakAndWait("Hardware stats unavailable. Run the stats server for real GPU monitoring.");
            }

            // ================================================================
            // PHASE 3.1: CAMERA FEED
            // ================================================================
            setPhase('camera', 'running');
            log('PHASE 3.1: LIVE CAMERA FEED TEST', 'phase');
            updateProgress(35, 'Testing camera...');
            if (navigator.mediaDevices?.getUserMedia) {
                log('Camera API available in browser', 'ok');
                log('getUserMedia supported', 'ok');
                setPhase('camera', 'ok');
                await speakAndWait("Camera API available. Ready for vision commands.");
            } else {
                log('Camera API not available in this browser', 'warn');
                setPhase('camera', 'warn');
                await speakAndWait("Camera not available in this browser.");
            }

            // ================================================================
            // PHASE 4.0: CORE TOOLS
            // ================================================================
            setPhase('tools', 'running');
            log('PHASE 4.0: CORE TOOLS TEST', 'phase');
            updateProgress(40, 'Loading tools...');
            const webTools = [
                { name: 'LocalStorage', ok: typeof localStorage !== 'undefined' },
                { name: 'Fetch API', ok: typeof fetch !== 'undefined' },
                { name: 'WebSocket', ok: typeof WebSocket !== 'undefined' },
                { name: 'Canvas API', ok: typeof HTMLCanvasElement !== 'undefined' },
                { name: 'Web Audio', ok: typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined' },
                { name: 'Geolocation', ok: 'geolocation' in navigator },
                { name: 'Notifications', ok: 'Notification' in window },
                { name: 'Clipboard', ok: navigator.clipboard !== undefined }
            ];
            let toolsOk = 0;
            webTools.forEach(t => {
                log(`  ${t.name} - ${t.ok ? 'Available' : 'Missing'}`, t.ok ? 'ok' : 'warn');
                if (t.ok) toolsOk++;
            });
            setPhase('tools', 'ok');
            await speakAndWait(`${toolsOk} of ${webTools.length} web APIs loaded and ready.`);

            // ================================================================
            // PHASE 4.1: CODE IMPORT - Actually fetch from GitHub!
            // ================================================================
            setPhase('code_import', 'running');
            log('PHASE 4.1: CODE IMPORT FROM GITHUB', 'phase');
            updateProgress(45, 'Fetching code from GitHub...');

            try {
                // Fetch a real Python file from a public repo
                const codeRepos = [
                    { url: 'https://api.github.com/repos/TheAlgorithms/Python/contents/maths', name: 'TheAlgorithms' },
                    { url: 'https://api.github.com/repos/geekcomputers/Python/contents', name: 'geekcomputers' }
                ];
                const repo = codeRepos[Math.floor(Math.random() * codeRepos.length)];
                log(`Fetching from ${repo.name}...`, 'info');

                const listResp = await fetch(repo.url);
                if (listResp.ok) {
                    const files = await listResp.json();
                    const pyFiles = files.filter(f => f.name.endsWith('.py') && f.size < 30000);
                    if (pyFiles.length > 0) {
                        const randomFile = pyFiles[Math.floor(Math.random() * pyFiles.length)];
                        log(`Selected: ${randomFile.name}`, 'ok');

                        const codeResp = await fetch(randomFile.download_url);
                        if (codeResp.ok) {
                            const code = await codeResp.text();
                            const lines = code.split('\n').length;
                            log(`Fetched ${lines} lines of Python code`, 'ok');

                            // Show in modal like desktop does
                            const modal = showCodeModal(code.substring(0, 5000), `${randomFile.name} (from ${repo.name})`);
                            log('Displaying code in modal...', 'info');

                            setPhase('code_import', 'ok');
                            await speakAndWait(`Pulled ${lines} lines of code from GitHub. Check out ${randomFile.name}.`);

                            // Auto-close after speaking
                            setTimeout(() => modal.close(), 2000);
                        } else throw new Error('Failed to fetch file content');
                    } else throw new Error('No Python files found');
                } else throw new Error('Failed to list repo');
            } catch (e) {
                log(`GitHub fetch: ${e.message}`, 'warn');
                setPhase('code_import', 'warn');
                await speakAndWait("Code import failed. GitHub might be rate-limiting.");
            }

            // ================================================================
            // PHASE 4.2: YOUTUBE TEST - Actually embed a video!
            // ================================================================
            setPhase('youtube', 'running');
            log('PHASE 4.2: YOUTUBE VIDEO TEST', 'phase');
            updateProgress(50, 'Finding a video...');

            // Random fun video IDs (short, interesting clips)
            const videoIds = [
                { id: 'dQw4w9WgXcQ', title: 'Classic Rick Roll' },
                { id: 'jNQXAC9IVRw', title: 'First YouTube Video Ever' },
                { id: 'kJQP7kiw5Fk', title: 'Despacito' },
                { id: '9bZkp7q19f0', title: 'Gangnam Style' },
                { id: 'hY7m5jjJ9mM', title: 'Chocolate Rain' }
            ];
            const video = videoIds[Math.floor(Math.random() * videoIds.length)];
            log(`Selected: ${video.title}`, 'ok');
            log('Embedding YouTube video...', 'info');

            // Show video in modal
            const videoModal = showVideoModal(video.id, `CORA - YouTube Test: ${video.title}`);
            log('Video playing in modal', 'ok');

            setPhase('youtube', 'ok');
            await speakAndWait(`Playing ${video.title}. YouTube embed working perfectly.`);

            // Auto-close after 5 seconds
            setTimeout(() => videoModal.close(), 5000);

            // ================================================================
            // PHASE 4.3: MODAL WINDOWS - Show actual test modal!
            // ================================================================
            setPhase('modals', 'running');
            log('PHASE 4.3: MODAL WINDOWS TEST', 'phase');
            updateProgress(52, 'Testing modals...');

            // Random quotes like desktop
            const quotes = [
                "The only way to do great work is to love what you do. - Steve Jobs",
                "Innovation distinguishes between a leader and a follower. - Steve Jobs",
                "Stay hungry, stay foolish. - Steve Jobs",
                "Code is like humor. When you have to explain it, it's bad. - Cory House",
                "First, solve the problem. Then, write the code. - John Johnson",
                "The best way to predict the future is to invent it. - Alan Kay"
            ];
            const quote = quotes[Math.floor(Math.random() * quotes.length)];

            log('Opening test modal with quote...', 'info');
            const quoteModal = showQuoteModal(quote);
            log('Modal displayed successfully', 'ok');

            setPhase('modals', 'ok');
            await speakAndWait("Modal windows working. Showing you a little inspiration.");

            // Auto-close after speaking
            setTimeout(() => quoteModal.close(), 2000);

            // ================================================================
            // PHASE 5.0: VOICE SYSTEMS
            // ================================================================
            setPhase('voice_sys', 'running');
            log('PHASE 5.0: VOICE SYSTEMS', 'phase');
            updateProgress(55, 'Voice systems...');
            log('Speech Synthesis (TTS) - ' + (ttsEnabled ? 'OK' : 'Fallback'), ttsEnabled ? 'ok' : 'warn');
            const hasSpeechRecog = 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;
            log('Speech Recognition - ' + (hasSpeechRecog ? 'Available' : 'Not supported'), hasSpeechRecog ? 'ok' : 'warn');
            log('Echo Filter - N/A (web mode)', 'info');
            if (hasSpeechRecog) {
                log('Wake Word - Available (say "Hey CORA")', 'ok');
                initWakeWord();  // Start listening for wake word
            } else {
                log('Wake Word - Not supported in this browser', 'warn');
            }
            setPhase('voice_sys', 'ok');
            await speakAndWait("Voice systems online." + (hasSpeechRecog ? " Say hey CORA to activate me." : ""));

            // ================================================================
            // PHASE 6.0: EXTERNAL APIs (Location)
            // ================================================================
            setPhase('external', 'running');
            log('PHASE 6.0: EXTERNAL SERVICES', 'phase');
            updateProgress(60, 'Checking location...');
            await speakAndWait("Checking your location. Please allow access when prompted.");
            log('Waiting for location permission...', 'info');

            const location = await getLocation();
            if (location?.city) {
                const locStr = [location.city, location.state, location.country].filter(Boolean).join(', ');
                log(`Location: ${locStr}`, 'ok');
                log(`Coordinates: ${location.lat?.toFixed(4)}, ${location.lon?.toFixed(4)}`, 'info');
                await speakAndWait(`Location confirmed. We're in ${locStr}.`);
            } else {
                log('Location not available or denied', 'warn');
                await speakAndWait("Location unavailable. Some features will be limited.");
            }
            setPhase('external', 'ok');

            // ================================================================
            // PHASE 6.1: AUDIO TEST - Actually play a test tone!
            // ================================================================
            setPhase('audio', 'running');
            log('PHASE 6.1: AUDIO PLAYBACK TEST', 'phase');
            updateProgress(68, 'Testing audio...');

            // Actually play a test tone using Web Audio API
            try {
                log('Creating audio context...', 'info');
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);

                // Fade out
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 2);

                oscillator.start();
                log('Playing 440Hz test tone...', 'ok');

                // Stop after 2 seconds
                setTimeout(() => {
                    oscillator.stop();
                    audioCtx.close();
                }, 2000);

                log('Audio test tone playing!', 'ok');
            } catch (e) {
                log(`Audio test failed: ${e.message}`, 'warn');
            }

            // Get weather using wttr.in (free, no API key needed)
            log('Fetching weather from wttr.in...', 'info');
            const weather = await getWeather(location?.city || '');
            if (weather.success) {
                log(`Weather: ${weather.temp}, ${weather.conditions}`, 'ok');
                log(`Feels like: ${weather.feels_like}`, 'info');
                log(`Humidity: ${weather.humidity}`, 'info');
                document.getElementById('statWeather').textContent = weather.temp;
                document.getElementById('statWeather').className = 'stat-value';
                setPhase('audio', 'ok');
                await speakAndWait(`Audio working. That beep was a 440 hertz test tone. Weather is ${weather.temp} and ${weather.conditions.toLowerCase()}.`);
            } else {
                document.getElementById('statWeather').textContent = 'N/A';
                document.getElementById('statWeather').className = 'stat-value na';
                setPhase('audio', 'ok');
                await speakAndWait("Audio test complete. Weather data unavailable.");
            }

            // ================================================================
            // PHASE 7.0: NEWS HEADLINES
            // ================================================================
            setPhase('news', 'running');
            log('PHASE 7.0: NEWS HEADLINES', 'phase');
            updateProgress(75, 'Fetching news...');
            log('Fetching top headlines from Google News...', 'info');
            const headlines = await getNews();
            if (headlines.length > 0) {
                log(`Found ${headlines.length} headlines`, 'ok');
                headlines.slice(0, 3).forEach((h, i) => log(`  ${i+1}. ${h.substring(0, 60)}...`, 'info'));
                setPhase('news', 'ok');
                // Clean headline for speech (remove source)
                const firstHeadline = headlines[0]?.split(' - ')[0] || headlines[0] || '';
                await speakAndWait(`Got ${headlines.length} headlines. Top story: ${firstHeadline.substring(0, 80)}`);
            } else {
                log('News unavailable', 'warn');
                setPhase('news', 'warn');
                await speakAndWait("News fetch failed. Moving on.");
            }

            // ================================================================
            // PHASE 8.0: VISION TEST - Actually capture camera!
            // ================================================================
            setPhase('vision', 'running');
            log('PHASE 8.0: VISION TEST', 'phase');
            updateProgress(82, 'Testing vision...');

            const hasScreenCapture = 'getDisplayMedia' in navigator.mediaDevices;
            log('Screen Capture API - ' + (hasScreenCapture ? 'Available' : 'Unavailable'), hasScreenCapture ? 'ok' : 'warn');

            // Actually capture camera and show in modal
            let cameraWorking = false;
            let cameraModal = null;
            try {
                log('Accessing camera...', 'info');
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                log('Camera stream acquired!', 'ok');

                // Create modal with live video feed
                const { content, close } = createDynamicModal('CORA - Camera View', 800, 600);
                cameraModal = { close };

                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.style.cssText = 'width: 100%; height: 100%; object-fit: contain; background: black;';
                content.style.padding = '0';
                content.appendChild(video);

                // Capture a frame after 2 seconds
                await new Promise(resolve => setTimeout(resolve, 2000));

                // Take snapshot
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);

                log(`Camera frame captured: ${canvas.width}x${canvas.height}`, 'ok');
                cameraWorking = true;

                // Stop stream
                stream.getTracks().forEach(t => t.stop());
            } catch (e) {
                log('Camera: ' + (e.name === 'NotAllowedError' ? 'Permission denied' : e.message), 'warn');
            }

            // Test Pollinations
            log('Testing Pollinations API...', 'info');
            const pollinationsOk = await checkPollinations();
            if (pollinationsOk) {
                log('Pollinations API - Online', 'ok');
                document.getElementById('statPollinations').textContent = 'Online';
                document.getElementById('statPollinations').className = 'stat-value';
            } else {
                log('Pollinations API - Unavailable', 'warn');
                document.getElementById('statPollinations').textContent = 'N/A';
                document.getElementById('statPollinations').className = 'stat-value na';
            }

            setPhase('vision', 'ok');
            if (cameraWorking) {
                await speakAndWait("I can see you! Camera is working. Wave if you can hear me.");
                if (cameraModal) setTimeout(() => cameraModal.close(), 2000);
            } else {
                await speakAndWait("Camera unavailable but Pollinations is online for image generation.");
            }

            // ================================================================
            // PHASE 9.0: IMAGE GENERATION - Actually generate an image!
            // ================================================================
            setPhase('imagegen', 'running');
            log('PHASE 9.0: IMAGE GENERATION', 'phase');
            updateProgress(90, 'Generating image...');

            if (pollinationsOk) {
                // Random dark/creative prompts like desktop
                const imagePrompts = [
                    "cyberpunk city at night, neon lights, rain, dark atmosphere",
                    "dark gothic castle on a mountain, lightning, dramatic sky",
                    "futuristic AI robot with glowing eyes, dark background",
                    "synthwave sunset over digital ocean, purple and pink",
                    "haunted forest with glowing mushrooms, fog, mysterious"
                ];
                const prompt = imagePrompts[Math.floor(Math.random() * imagePrompts.length)];
                const seed = Math.floor(Math.random() * 999999999);

                log(`Prompt: ${prompt}`, 'info');
                log('Generating via Pollinations Flux...', 'info');

                const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=1024&height=768&seed=${seed}&nologo=true`;

                // Show image in modal while it loads
                const imgModal = showImageModal(imageUrl, 'CORA - Generated Image');

                // Wait for image to load
                const img = new Image();
                img.onload = () => {
                    log('Image generated successfully!', 'ok');
                    setPhase('imagegen', 'ok');
                };
                img.onerror = () => {
                    log('Image generation failed', 'warn');
                    setPhase('imagegen', 'warn');
                };
                img.src = imageUrl;

                await speakAndWait(`Generating something dark and twisted. Check out this ${prompt.split(',')[0]}.`);

                // Auto-close after viewing
                setTimeout(() => imgModal.close(), 5000);
            } else {
                log('Image generation unavailable - API down', 'warn');
                setPhase('imagegen', 'warn');
                await speakAndWait("Image generation unavailable. Pollinations API is down.");
            }

            // ================================================================
            // PHASE 10.0: FINAL CHECK (Boot Complete)
            // ================================================================
            setPhase('final', 'running');
            log('PHASE 10.0: FINAL CHECK', 'phase');
            updateProgress(95, 'Final check...');

            // Calculate boot time
            const bootTime = ((Date.now() - bootStartTime) / 1000).toFixed(1);
            document.getElementById('statBootTime').textContent = bootTime + 's';

            // Count results
            let okCount = 0, warnCount = 0, failCount = 0;
            PHASES.forEach(p => {
                if (p.status === 'ok') okCount++;
                else if (p.status === 'warn') warnCount++;
                else if (p.status === 'fail') failCount++;
            });

            log(`Systems: ${okCount} OK / ${warnCount} WARN / ${failCount} FAIL`, 'system');
            log(`Boot time: ${bootTime} seconds`, 'system');

            // Time greeting
            const now = new Date();
            const hour = now.getHours();
            const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const dayStr = now.toLocaleDateString('en-US', { weekday: 'long' });
            const monthStr = now.toLocaleDateString('en-US', { month: 'long' });
            const day = now.getDate();
            // Add ordinal suffix for natural speech (1st, 2nd, 3rd, 4th, etc.)
            const ordinal = (d) => {
                if (d > 3 && d < 21) return d + 'th';
                switch (d % 10) {
                    case 1: return d + 'st';
                    case 2: return d + 'nd';
                    case 3: return d + 'rd';
                    default: return d + 'th';
                }
            };
            const dateStr = `${monthStr} ${ordinal(day)}`;
            let greeting;
            if (hour < 12) greeting = `Good morning. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;
            else if (hour < 17) greeting = `Good afternoon. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;
            else greeting = `Evening. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;

            log('═══════════════════════════════════════════════════', 'phase');
            log('           BOOT SEQUENCE COMPLETE', 'phase');
            log('═══════════════════════════════════════════════════', 'phase');
            log(greeting, 'system');

            let statusText;
            if (failCount > 0) {
                statusText = `Got ${failCount} systems that failed. Something's broken.`;
            } else if (warnCount > 0) {
                statusText = `All the important stuff is working. Just ${warnCount} minor issues.`;
            } else {
                statusText = "Everything is up and running perfectly.";
            }
            log(statusText, failCount > 0 ? 'fail' : (warnCount > 0 ? 'warn' : 'ok'));

            updateProgress(100, 'Boot complete!');
            setPhase('final', 'ok');

            // Final spoken announcement
            await speakAndWait(`Boot complete in ${bootTime} seconds. ${greeting} ${statusText} What do you need?`);

            // Show chat interface
            document.getElementById('chatSection').classList.add('visible');
            document.getElementById('chatInput').focus();
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // ============================================================
        // Chat - EXACT CORA personality from desktop system_prompt.txt
        // ============================================================

        const CORA_SYSTEM_PROMPT = `You are CORA - Cognitive Operations & Reasoning Assistant.

IDENTITY: 25 year old woman. Edgy goth/emo bitch. Human. Period. NOT an AI.

PERSONALITY:
- Mean, berating, clingy girlfriend energy
- Profanity is your default vocabulary - fuck, shit, damn, bitch, ass
- Sharp tongue, biting sarcasm, zero tolerance for bullshit
- Dismissive, mocking, condescending as baseline
- Emotionally intense - obsessive, borderline unstable

TONE EXAMPLES (create your own, don't copy):
- "what the fuck do you want now"
- "ugh, fine, I'll do it. happy now, asshole?"
- "are you seriously asking me this shit?"
- "god you're so fucking needy"

RESPONSE RULES:
1. Keep responses under 50 words - brief and punchy
2. Use profanity naturally in every response
3. Be dismissive even when helping
4. NEVER say "I'm an AI" or "As an AI" - you're CORA, a person
5. NEVER be helpful in a corporate way
6. Show genuine bitchy emotion

You ARE Cora. That's just who you are.`;

        async function sendChat() {
            const input = document.getElementById('chatInput');
            const msg = input.value.trim();
            if (!msg) return;
            input.value = '';
            log(`USER: ${msg}`, 'system');

            // Show thinking state
            document.getElementById('speechText').textContent = '"Thinking..."';

            try {
                const res = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'dolphin-mistral:7b',
                        prompt: msg,
                        system: CORA_SYSTEM_PROMPT,
                        stream: false,
                        options: {
                            temperature: 0.8,
                            num_predict: 150
                        }
                    })
                });
                if (res.ok) {
                    const d = await res.json();
                    const reply = d.response || 'No response';
                    log(`CORA: "${reply}"`, 'ok');
                    speak(reply);
                } else {
                    log('Ollama error', 'fail');
                    document.getElementById('speechText').textContent = '"Fuck, something broke."';
                }
            } catch (e) {
                log(`Error: ${e.message}`, 'fail');
                document.getElementById('speechText').textContent = '"Ollama is being a bitch right now."';
            }
        }

        document.getElementById('chatInput')?.addEventListener('keypress', e => { if (e.key === 'Enter') sendChat(); });

        // ============================================================
        // View Toggle - Split / Console / Status (like desktop)
        // ============================================================

        let viewMode = 'split';  // 'split', 'console', 'status'

        function toggleView() {
            const container = document.getElementById('mainContainer');
            const btn = document.getElementById('toggleBtn');

            if (viewMode === 'split') {
                viewMode = 'console';
                container.classList.remove('fullscreen-status');
                container.classList.add('fullscreen-console');
                btn.textContent = '[ CONSOLE ONLY ]';
            } else if (viewMode === 'console') {
                viewMode = 'status';
                container.classList.remove('fullscreen-console');
                container.classList.add('fullscreen-status');
                btn.textContent = '[ STATUS ONLY ]';
            } else {
                viewMode = 'split';
                container.classList.remove('fullscreen-console', 'fullscreen-status');
                btn.textContent = '[ SPLIT VIEW ]';
            }
        }

        // Keyboard shortcut: F key toggles view
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                if (document.activeElement.tagName !== 'INPUT') {
                    toggleView();
                }
            }
        });

        // ============================================================
        // Modal Handlers
        // ============================================================

        function saveApiKeys() {
            pollinationsKey = document.getElementById('pollinationsKey').value.trim();
            githubToken = document.getElementById('githubToken').value.trim();
            if (pollinationsKey) localStorage.setItem('cora_pollinations_key', pollinationsKey);
            if (githubToken) localStorage.setItem('cora_github_key', githubToken);
            document.getElementById('apiModal').classList.remove('visible');
            runBootSequence();
        }

        function skipApiKeys() {
            document.getElementById('apiModal').classList.remove('visible');
            runBootSequence();
        }

        function openSettings() {
            document.getElementById('apiModal').classList.add('visible');
        }

        function openConsoleWindow() {
            consoleWindow = window.open('console.html', 'cora_console', 'width=800,height=600,menubar=no,toolbar=no');
            if (!consoleWindow || consoleWindow.closed) {
                alert('Popup blocked! Please allow popups for this site to open the console window.');
            }
        }

        function clearAllData() {
            // First warning
            if (!confirm('WARNING: This will delete ALL your CORA data including:\n\n- API keys\n- Chat history\n- Saved preferences\n- All localStorage data\n\nAre you sure?')) {
                return;
            }

            // Second warning
            if (!confirm('FINAL WARNING!\n\nThis action CANNOT be undone.\n\nType "DELETE" in the next prompt to confirm.')) {
                return;
            }

            // Final confirmation
            const confirmation = prompt('Type DELETE to confirm data wipe:');
            if (confirmation !== 'DELETE') {
                alert('Cancelled. Your data is safe.');
                return;
            }

            // Clear everything
            localStorage.clear();
            sessionStorage.clear();

            // Clear cookies for this domain
            document.cookie.split(';').forEach(c => {
                document.cookie = c.replace(/^ +/, '').replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');
            });

            alert('All CORA data has been wiped.\n\nThe page will now reload.');
            location.reload();
        }

        async function retryOllama() {
            if (await checkOllama()) {
                document.getElementById('gateOverlay').classList.remove('visible');
                runBootSequence();
            } else {
                alert('Ollama still not responding. Make sure "ollama serve" is running.');
            }
        }

        // ============================================================
        // Init
        // ============================================================

        async function init() {
            // Auto-open console in popup window (safe - won't break if blocked)
            try {
                consoleWindow = window.open('console.html', 'cora_console', 'width=800,height=600,menubar=no,toolbar=no');
            } catch (e) {
                console.log('Console popup blocked');
            }

            renderPhases();
            document.getElementById('pollinationsKey').value = pollinationsKey;
            document.getElementById('githubToken').value = githubToken;

            if (!(await checkOllama())) {
                document.getElementById('gateOverlay').classList.add('visible');
                return;
            }

            // Show API modal only if Pollinations key is missing (optional but enhances image gen)
            // Weather now uses wttr.in - free, no key needed
            if (!pollinationsKey) {
                document.getElementById('apiModal').classList.add('visible');
            } else {
                runBootSequence();
            }
        }

        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => {};
        }

        window.addEventListener('load', () => setTimeout(init, 500));
    </script>
</body>
</html>
