<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C.O.R.A - Cognitive Operations & Reasoning Assistant</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="C.O.R.A - A Windows 11 AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, image generation, and live system monitoring. Built by Unity AI Lab.">
    <meta name="keywords" content="CORA, AI Assistant, Ollama, Voice Assistant, Unity AI Lab, Windows 11, Personal Assistant">
    <meta name="author" content="Unity AI Lab - Hackall360, Sponge, GFourteen">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://www.unityailab.com/CORA/">
    <meta property="og:title" content="C.O.R.A - Cognitive Operations & Reasoning Assistant">
    <meta property="og:description" content="AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, image generation, and live system monitoring. Open source by Unity AI Lab.">
    <meta property="og:image" content="http://www.unityailab.com/CORA/images/social-preview.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Unity AI Lab">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="http://www.unityailab.com/CORA/">
    <meta name="twitter:title" content="C.O.R.A - Cognitive Operations & Reasoning Assistant">
    <meta name="twitter:description" content="AI-powered personal assistant with visual boot display, voice synthesis, vision analysis, and image generation. Open source by Unity AI Lab.">
    <meta name="twitter:image" content="http://www.unityailab.com/CORA/images/social-preview.png">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="images/social-preview.png">

    <style>
        :root {
            --bg-main: #0a0a0a;
            --bg-panel: #12121a;
            --bg-darker: #08080c;
            --border-color: #302050;
            --text-main: #e0e0e0;
            --text-dim: #888;
            --accent-magenta: #ff00ff;
            --accent-cyan: #00ffff;
            --ok-color: #00ff88;
            --warn-color: #ffaa00;
            --fail-color: #ff4444;
            --pending-color: #666;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: var(--bg-main);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
        }

        /* Two Column Layout - matches desktop boot_display.py */
        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
            gap: 0;
            transition: grid-template-columns 0.3s ease;
        }

        /* Fullscreen mode - console only */
        .container.fullscreen-console {
            grid-template-columns: 0 1fr;
        }
        .container.fullscreen-console .left-panel {
            display: none;
        }

        /* Fullscreen mode - status only */
        .container.fullscreen-status {
            grid-template-columns: 1fr 0;
        }
        .container.fullscreen-status .right-panel {
            display: none;
        }

        /* Toggle button */
        .toggle-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
        }
        .toggle-btn:hover {
            background: var(--accent-magenta);
            color: #000;
        }

        /* Left Panel */
        .left-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #1a0020 0%, #0d0015 100%);
            border-bottom: 2px solid var(--accent-magenta);
            padding: 15px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            color: var(--accent-magenta);
            text-shadow: 0 0 15px var(--accent-magenta);
            letter-spacing: 8px;
        }

        .header .subtitle {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 5px;
        }

        .header .version {
            font-size: 11px;
            color: var(--accent-cyan);
            margin-top: 3px;
        }

        /* Waveform - EXACT match to boot_display.py */
        .waveform-container {
            background: #0a0a0a;
            border: 1px solid #302050;
            margin: 10px;
            border-radius: 4px;
            position: relative;
        }

        .waveform-label {
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 9px;
            color: #666;
            z-index: 1;
        }

        #waveformCanvas {
            width: 100%;
            height: 100px;
            display: block;
        }

        /* Speech Text - EXACT like desktop boot_display.py */
        .speech-container {
            background: linear-gradient(180deg, #1a0020 0%, #0d0010 100%);
            border-bottom: 2px solid var(--accent-magenta);
            padding: 15px;
            min-height: 80px;
        }

        .speech-label {
            font-size: 10px;
            color: var(--accent-cyan);
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        #speechText {
            font-size: 14px;
            color: var(--accent-magenta);
            font-style: italic;
            line-height: 1.5;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
            min-height: 42px;
        }

        .tts-notice {
            font-size: 9px;
            color: #555;
            margin-top: 8px;
            font-style: normal;
        }

        .tts-notice a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        /* Progress Bar */
        .progress-container {
            padding: 10px 15px;
            background: var(--bg-darker);
            border-bottom: 1px solid var(--border-color);
        }

        .progress-bar {
            height: 6px;
            background: #1a1a2a;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-magenta), var(--accent-cyan));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 5px;
            text-align: center;
        }

        /* Phases */
        .phases-container {
            padding: 10px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            max-height: 260px;
            overflow-y: auto;
        }

        .phases-header {
            font-size: 10px;
            color: var(--accent-cyan);
            text-align: center;
            margin-bottom: 8px;
        }

        .phases-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .phase-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            padding: 3px 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
        }

        .phase-indicator {
            font-size: 10px;
            width: 14px;
            text-align: center;
        }

        .phase-indicator.pending { color: var(--pending-color); }
        .phase-indicator.running { color: var(--accent-magenta); animation: pulse 1s infinite; }
        .phase-indicator.ok { color: var(--ok-color); }
        .phase-indicator.warn { color: var(--warn-color); }
        .phase-indicator.fail { color: var(--fail-color); }

        @keyframes pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 5px var(--accent-magenta); }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stats-section {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .stats-panel {
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .stats-header {
            font-size: 10px;
            color: var(--accent-cyan);
            text-align: center;
            margin-bottom: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }

        .stat-label { color: var(--text-dim); }
        .stat-value { color: var(--ok-color); font-weight: bold; }
        .stat-value.warn { color: var(--warn-color); }
        .stat-value.na { color: var(--text-dim); font-weight: normal; }

        .web-notice {
            background: #1a1020;
            border: 1px solid #402050;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
            text-align: center;
        }

        .web-notice-title {
            color: var(--warn-color);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .web-notice a {
            color: var(--accent-cyan);
            text-decoration: none;
        }

        /* Right Panel - Log */
        .right-panel {
            background: var(--bg-main);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .log-header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            padding: 10px 15px;
            font-size: 12px;
            color: var(--accent-cyan);
        }

        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-line { margin-bottom: 2px; }
        .log-phase { color: var(--accent-magenta); font-weight: bold; margin-top: 10px; }
        .log-ok { color: var(--ok-color); }
        .log-warn { color: var(--warn-color); }
        .log-fail { color: var(--fail-color); }
        .log-info { color: var(--text-dim); }
        .log-system { color: var(--accent-cyan); }
        .log-cora { color: #ff69b4; font-weight: bold; }  /* Hot pink for CORA speech */

        /* Chat */
        .chat-section {
            display: none;
            border-top: 1px solid var(--border-color);
            padding: 15px;
            background: var(--bg-panel);
        }

        .chat-section.visible { display: block; }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        #chatInput {
            flex: 1;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            color: var(--text-main);
            font-family: inherit;
            font-size: 13px;
        }

        #chatInput:focus {
            outline: none;
            border-color: var(--accent-magenta);
        }

        #sendBtn {
            background: linear-gradient(135deg, var(--accent-magenta), #aa00aa);
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.visible { display: flex; }

        .modal {
            background: var(--bg-panel);
            border: 2px solid var(--accent-magenta);
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            color: var(--accent-magenta);
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-field {
            margin-bottom: 20px;
        }

        .modal-field label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-main);
        }

        .modal-field input {
            width: 100%;
            padding: 10px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-main);
            font-family: inherit;
        }

        .modal-field a {
            color: var(--accent-cyan);
            font-size: 12px;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-magenta);
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }

        .gate-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 999;
            align-items: center;
            justify-content: center;
        }

        .gate-overlay.visible { display: flex; }

        .gate-box {
            background: #1a0000;
            border: 2px solid var(--fail-color);
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }

        .gate-box h2 {
            color: var(--fail-color);
            margin-bottom: 15px;
        }

        .gate-box pre {
            background: #0a0a0a;
            padding: 15px;
            border-radius: 4px;
            text-align: left;
            margin: 15px 0;
            color: var(--accent-cyan);
        }

        .gate-box button {
            padding: 12px 30px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 4px;
            color: black;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <!-- Ollama Gate -->
    <div class="gate-overlay" id="gateOverlay">
        <div class="gate-box">
            <h2>[ BLOCKED ]</h2>
            <p>Ollama is not running</p>
            <pre>ollama serve</pre>
            <p style="color: var(--text-dim); font-size: 12px;">Run this in your terminal, then click Retry</p>
            <button onclick="retryOllama()">Retry Connection</button>
        </div>
    </div>

    <!-- API Key Modal -->
    <div class="modal-overlay" id="apiModal">
        <div class="modal">
            <h2>API Configuration</h2>
            <div class="modal-field">
                <label>Pollinations API Key (optional)</label>
                <input type="password" id="pollinationsKey" placeholder="pk_...">
                <a href="https://pollinations.ai" target="_blank">Get key at pollinations.ai</a>
            </div>
            <div class="modal-field">
                <label>GitHub Token (optional)</label>
                <input type="password" id="githubToken" placeholder="ghp_...">
                <a href="https://github.com/settings/tokens" target="_blank">Generate at github.com/settings/tokens</a>
            </div>
            <div class="modal-field">
                <label>Weather API Key (optional)</label>
                <input type="password" id="weatherKey" placeholder="Your OpenWeatherMap key">
                <a href="https://openweathermap.org/api" target="_blank">Get free key at openweathermap.org</a>
            </div>
            <button class="modal-btn" onclick="saveApiKeys()">Save & Continue</button>
            <button class="modal-btn" style="background: #333; margin-top: 10px;" onclick="skipApiKeys()">Skip (Limited Features)</button>
        </div>
    </div>

    <!-- Toggle Button -->
    <button class="toggle-btn" id="toggleBtn" onclick="toggleView()">[ SPLIT VIEW ]</button>

    <!-- Main Container -->
    <div class="container" id="mainContainer">
        <div class="left-panel">
            <div class="header">
                <h1>C.O.R.A</h1>
                <div class="subtitle">Cognitive Operations & Reasoning Assistant</div>
                <div class="version">v2.4.0 - Unity AI Lab</div>
            </div>

            <div class="waveform-container">
                <div class="waveform-label">▶ VOICE SYNTHESIS</div>
                <canvas id="waveformCanvas"></canvas>
            </div>

            <div class="speech-container">
                <div class="speech-label">▶ CORA SPEAKING</div>
                <div id="speechText">"Initializing..."</div>
                <div class="tts-notice" id="ttsNotice">Loading Kokoro neural voice (af_bella)...</div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Booting...</div>
            </div>

            <div class="phases-container">
                <div class="phases-header">── BOOT PHASES ──</div>
                <div class="phases-grid" id="phasesSection"></div>
            </div>

            <div class="stats-section">
                <div class="stats-panel">
                    <div class="stats-header">── LIVE SYSTEM STATS ──</div>
                    <div class="stats-grid">
                        <div class="stat-item"><span class="stat-label">CPU:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">MEM:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">DISK:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">GPU:</span><span class="stat-value na">N/A</span></div>
                        <div class="stat-item"><span class="stat-label">VRAM:</span><span class="stat-value na">0%</span></div>
                        <div class="stat-item"><span class="stat-label">NET:</span><span class="stat-value" id="statNet">--</span></div>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stats-header">── SERVICE STATUS ──</div>
                    <div class="stats-grid">
                        <div class="stat-item"><span class="stat-label">Ollama:</span><span class="stat-value" id="statOllama">--</span></div>
                        <div class="stat-item"><span class="stat-label">Pollinations:</span><span class="stat-value" id="statPollinations">--</span></div>
                        <div class="stat-item"><span class="stat-label">Weather:</span><span class="stat-value" id="statWeather">--</span></div>
                        <div class="stat-item"><span class="stat-label">Boot:</span><span class="stat-value" id="statBootTime">--</span></div>
                    </div>
                </div>

                <div class="web-notice">
                    <div class="web-notice-title">WEB VERSION</div>
                    <div>Full C.O.R.A running in your browser!<br>
                    <a href="https://github.com/Unity-Lab-AI/CORA.git" target="_blank">Get source on GitHub</a></div>
                </div>
            </div>

            <div class="chat-section" id="chatSection">
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Talk to CORA...">
                    <button id="sendBtn" onclick="sendChat()">Send</button>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="log-header">[ BOOT CONSOLE ]</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>

    <script>
        // ============================================================
        // C.O.R.A Web Interface - Full Boot Sequence with TTS
        // Matches desktop boot_sequence.py exactly
        // ============================================================

        // EXACT match to desktop boot_sequence.py phases (18 total)
        const PHASES = [
            { id: 'waveform', name: '0.8 Waveform Init', status: 'pending' },
            { id: 'about', name: '0.9 About CORA', status: 'pending' },
            { id: 'voice', name: '1.0 Voice Synthesis', status: 'pending' },
            { id: 'ai_engine', name: '2.0 AI Engine', status: 'pending' },
            { id: 'ai_models', name: '2.1 AI Models', status: 'pending' },
            { id: 'hardware', name: '3.0 Hardware Check', status: 'pending' },
            { id: 'camera', name: '3.1 Camera Feed', status: 'pending' },
            { id: 'tools', name: '4.0 Core Tools', status: 'pending' },
            { id: 'code_import', name: '4.1 Code Import', status: 'pending' },
            { id: 'youtube', name: '4.2 YouTube Test', status: 'pending' },
            { id: 'modals', name: '4.3 Modal Windows', status: 'pending' },
            { id: 'voice_sys', name: '5.0 Voice Systems', status: 'pending' },
            { id: 'external', name: '6.0 External APIs', status: 'pending' },
            { id: 'audio', name: '6.1 Audio Test', status: 'pending' },
            { id: 'news', name: '7.0 News Headlines', status: 'pending' },
            { id: 'vision', name: '8.0 Vision Test', status: 'pending' },
            { id: 'imagegen', name: '9.0 Image Gen', status: 'pending' },
            { id: 'final', name: '10.0 Final Check', status: 'pending' }
        ];

        let bootStartTime = null;
        let waveformActive = false;
        let waveformCtx = null;
        let animationId = null;

        let pollinationsKey = localStorage.getItem('cora_pollinations_key') || '';
        let githubToken = localStorage.getItem('cora_github_key') || '';
        let weatherKey = localStorage.getItem('cora_weather_key') || '';

        // ============================================================
        // KOKORO TTS - Neural voice (same as desktop af_bella)
        // Falls back to Web Speech API if Kokoro fails
        // ============================================================

        let kokoroWorker = null;
        let kokoroReady = false;
        let kokoroLoading = false;
        let audioContext = null;
        let pendingCallbacks = {};
        let messageId = 0;
        let useFallbackTTS = false;

        async function initKokoro(progressCallback) {
            if (kokoroReady) return true;
            if (kokoroLoading) return false;

            kokoroLoading = true;

            try {
                // Create audio context (must happen on user interaction for some browsers)
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Create web worker
                kokoroWorker = new Worker('kokoro-worker.js', { type: 'module' });

                return new Promise((resolve) => {
                    const initId = ++messageId;

                    kokoroWorker.onmessage = (e) => {
                        const { type, id, data, error } = e.data;

                        if (type === 'progress' && id === initId) {
                            if (progressCallback) progressCallback(data.message, data.progress);
                        }
                        else if (type === 'initComplete' && id === initId) {
                            kokoroReady = true;
                            kokoroLoading = false;
                            resolve(true);
                        }
                        else if (type === 'error' && id === initId) {
                            console.error('Kokoro init error:', error);
                            kokoroLoading = false;
                            resolve(false);
                        }
                        else if (type === 'audioReady') {
                            handleAudioReady(id, data);
                        }
                        else if (type === 'generating') {
                            // Audio is being generated, keep waveform active
                        }
                    };

                    kokoroWorker.postMessage({ type: 'init', id: initId, data: {} });
                });

            } catch (e) {
                console.error('Failed to init Kokoro:', e);
                kokoroLoading = false;
                return false;
            }
        }

        function handleAudioReady(id, data) {
            if (!pendingCallbacks[id]) return;

            const { resolve, startTime } = pendingCallbacks[id];
            delete pendingCallbacks[id];

            try {
                // Convert ArrayBuffer back to Float32Array
                const float32Audio = new Float32Array(data.audio);
                const sampleRate = data.sampleRate || 24000;

                // Feed audio samples to waveform for visualization
                // Downsample to ~100 samples for waveform display
                const step = Math.max(1, Math.floor(float32Audio.length / 100));
                const waveformSamples = [];
                for (let i = 0; i < float32Audio.length; i += step) {
                    waveformSamples.push(float32Audio[i]);
                }
                feedAudioChunk(waveformSamples);

                // Create audio buffer and play it
                const audioBuffer = audioContext.createBuffer(1, float32Audio.length, sampleRate);
                audioBuffer.copyToChannel(float32Audio, 0);

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                // Create analyser to feed real-time audio to waveform
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                const dataArray = new Float32Array(analyser.frequencyBinCount);

                // Update waveform while playing
                let animFrame;
                const updateWaveform = () => {
                    analyser.getFloatTimeDomainData(dataArray);
                    feedAudioChunk(Array.from(dataArray));
                    if (audio_is_active) {
                        animFrame = requestAnimationFrame(updateWaveform);
                    }
                };

                source.onended = () => {
                    cancelAnimationFrame(animFrame);
                    stopWaveform();
                    resolve();
                };

                startWaveform();
                source.start();
                updateWaveform();

            } catch (e) {
                console.error('Audio playback error:', e);
                stopWaveform();
                resolve();
            }
        }

        function speak(text, callback) {
            // Show speech text with quotes like desktop boot_display.py
            document.getElementById('speechText').textContent = `"${text}"`;

            // Log CORA speech in hot pink to stand out
            log(`CORA: "${text}"`, 'cora');

            if (kokoroReady && !useFallbackTTS) {
                // Use Kokoro neural TTS
                const id = ++messageId;
                pendingCallbacks[id] = {
                    resolve: callback || (() => {}),
                    startTime: Date.now()
                };

                startWaveform();
                kokoroWorker.postMessage({
                    type: 'generate',
                    id,
                    data: { text, voice: 'af_bella', speed: 1.0 }
                });
            } else {
                // Fallback to Web Speech API
                if ('speechSynthesis' in window) {
                    const synth = window.speechSynthesis;
                    synth.cancel();

                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.0;
                    utterance.pitch = 1.1;

                    const voices = synth.getVoices();
                    const femaleVoice = voices.find(v =>
                        v.name.includes('Zira') || v.name.includes('Samantha') ||
                        v.name.toLowerCase().includes('female')
                    ) || voices[0];
                    if (femaleVoice) utterance.voice = femaleVoice;

                    utterance.onstart = () => startWaveform();
                    utterance.onend = () => { stopWaveform(); if (callback) callback(); };
                    utterance.onerror = () => { stopWaveform(); if (callback) callback(); };

                    synth.speak(utterance);
                } else {
                    if (callback) setTimeout(callback, 100);
                }
            }
        }

        function speakAndWait(text) {
            return new Promise(resolve => speak(text, resolve));
        }

        // ============================================================
        // WAVEFORM - EXACT 1:1 PORT FROM boot_display.py AudioWaveform
        // Lines 127-384 of boot_display.py
        // THIS RUNS FOREVER - NEVER STOPS
        // ============================================================

        // EXACT values from boot_display.py lines 140-146
        const NUM_POINTS = 100;  // self.num_points = 100
        let wave_points = new Array(NUM_POINTS).fill(0.0);  // self.wave_points
        let sample_buffer = new Array(NUM_POINTS).fill(0.0);  // self.sample_buffer

        // Audio state - like _audio_buffer_singleton in desktop
        let audio_chunk = null;  // Current audio samples
        let audio_chunk_time = null;  // When chunk was received
        let audio_is_active = false;  // Is TTS currently speaking

        function initWaveform() {
            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            waveformCtx = canvas.getContext('2d');
            waveformCtx.scale(2, 2);

            // Start animation - RUNS FOREVER, NEVER STOPS (line 212)
            _animate();
        }

        // These just set the audio state - animation NEVER stops
        function startWaveform() {
            audio_is_active = true;
            audio_chunk_time = Date.now();
        }

        function stopWaveform() {
            audio_is_active = false;
        }

        // Feed actual audio samples to waveform (like _audio_buffer_singleton)
        function feedAudioChunk(samples) {
            audio_chunk = samples;
            audio_chunk_time = Date.now();
        }

        function _animate() {
            // EXACT port of boot_display.py _animate() lines 205-322
            // "This runs FOREVER once started - never stops."

            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            // Check for audio - like lines 219-236
            let has_audio = false;
            let chunk = null;

            if (audio_chunk_time !== null) {
                const time_since_chunk = Date.now() - audio_chunk_time;
                // Accept chunks up to 300ms old (line 231)
                if (audio_chunk !== null && time_since_chunk < 300 && audio_is_active) {
                    has_audio = true;
                    chunk = audio_chunk;
                }
            }

            if (has_audio && chunk !== null) {
                // Process audio chunk - lines 240-305
                const chunk_len = chunk.length;
                const samples_to_add = Math.min(20, Math.floor(NUM_POINTS / 5));  // line 254

                if (chunk_len >= samples_to_add) {
                    // Downsample - line 258-259
                    const new_samples = [];
                    for (let i = 0; i < samples_to_add; i++) {
                        const idx = Math.floor(i * chunk_len / samples_to_add);
                        new_samples.push(chunk[idx]);
                    }

                    // Find peak for adaptive scaling - lines 263-270
                    let chunk_peak = 0;
                    for (let i = 0; i < chunk.length; i++) {
                        chunk_peak = Math.max(chunk_peak, Math.abs(chunk[i]));
                    }
                    let scale_factor = 20.0;
                    if (chunk_peak > 0.001) {
                        scale_factor = Math.min(0.95 / chunk_peak, 40.0);
                    }

                    // Scale and clamp - lines 270-273
                    for (let i = 0; i < new_samples.length; i++) {
                        new_samples[i] = Math.max(-1.0, Math.min(1.0, new_samples[i] * scale_factor));
                    }

                    // Shift buffer left, add new on right - line 276
                    sample_buffer = sample_buffer.slice(samples_to_add).concat(new_samples);
                }

                // Smooth transition - lines 302-305
                for (let i = 0; i < NUM_POINTS; i++) {
                    wave_points[i] = wave_points[i] * 0.3 + sample_buffer[i] * 0.7;
                }

            } else {
                // No audio - DECAY toward zero (lines 312-316)
                // Desktop behavior: NO fake waves, only real audio or decay
                const decay = 0.92;
                for (let i = 0; i < NUM_POINTS; i++) {
                    wave_points[i] *= decay;
                    sample_buffer[i] *= decay;
                }
            }

            // Draw the wave - line 319
            _draw_wave(width, height);

            // Schedule next frame - 25ms = ~40 FPS - line 322
            setTimeout(() => requestAnimationFrame(_animate), 25);
        }

        function _draw_wave(width, height) {
            // Symmetric waveform - expands OUT from center, collapses TO center at silence
            const ctx = waveformCtx;
            const center_y = height / 2;
            const max_amp = (height / 2) - 5;

            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Center reference line (dim)
            ctx.strokeStyle = '#201030';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, center_y);
            ctx.lineTo(width, center_y);
            ctx.stroke();

            // Build coordinates for top and bottom curves
            // Amplitude expands symmetrically from center
            const step = width / (NUM_POINTS - 1);
            const topCoords = [];
            const bottomCoords = [];

            for (let i = 0; i < NUM_POINTS; i++) {
                const x = i * step;
                const amp = Math.abs(wave_points[i]) * max_amp;
                topCoords.push([x, center_y - amp]);      // Above center
                bottomCoords.push([x, center_y + amp]);   // Below center (mirror)
            }

            if (topCoords.length >= 4) {
                // 4 glow layers
                const layers = [
                    { color: '#400060', width: 8 },   // Outer glow
                    { color: '#8000a0', width: 5 },   // Mid glow
                    { color: '#ff40ff', width: 3 },   // Main wave
                    { color: '#ffc0ff', width: 1 }    // Bright core
                ];

                // Draw each layer as a closed shape (top curve + bottom curve mirrored)
                layers.forEach(layer => {
                    ctx.strokeStyle = layer.color;
                    ctx.lineWidth = layer.width;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Draw top curve (above center)
                    ctx.beginPath();
                    ctx.moveTo(topCoords[0][0], topCoords[0][1]);
                    for (let i = 1; i < topCoords.length - 1; i++) {
                        const xc = (topCoords[i][0] + topCoords[i + 1][0]) / 2;
                        const yc = (topCoords[i][1] + topCoords[i + 1][1]) / 2;
                        ctx.quadraticCurveTo(topCoords[i][0], topCoords[i][1], xc, yc);
                    }
                    ctx.lineTo(topCoords[topCoords.length - 1][0], topCoords[topCoords.length - 1][1]);
                    ctx.stroke();

                    // Draw bottom curve (below center - mirror)
                    ctx.beginPath();
                    ctx.moveTo(bottomCoords[0][0], bottomCoords[0][1]);
                    for (let i = 1; i < bottomCoords.length - 1; i++) {
                        const xc = (bottomCoords[i][0] + bottomCoords[i + 1][0]) / 2;
                        const yc = (bottomCoords[i][1] + bottomCoords[i + 1][1]) / 2;
                        ctx.quadraticCurveTo(bottomCoords[i][0], bottomCoords[i][1], xc, yc);
                    }
                    ctx.lineTo(bottomCoords[bottomCoords.length - 1][0], bottomCoords[bottomCoords.length - 1][1]);
                    ctx.stroke();
                });
            }
        }

        // ============================================================
        // Logging & Phases
        // ============================================================

        // BroadcastChannel to send logs to separate console window
        const consoleChannel = new BroadcastChannel('cora_console');

        function log(text, type = 'info') {
            const container = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            const line = document.createElement('div');
            line.className = `log-line log-${type}`;

            let fullText;
            if (type === 'phase') {
                line.style.marginTop = '10px';
                fullText = `[${timestamp}] ═══════════════ ${text} ═══════════════`;
            } else {
                const prefix = type === 'ok' ? '✓' : type === 'warn' ? '⚠' : type === 'fail' ? '✗' : '';
                fullText = `[${timestamp}] ${prefix ? prefix + ' ' : ''}${text}`;
            }
            line.textContent = fullText;

            container.appendChild(line);
            container.scrollTop = container.scrollHeight;

            // Send to console window via BroadcastChannel
            consoleChannel.postMessage({ type: 'log', text: fullText, logType: type });
        }

        function renderPhases() {
            const container = document.getElementById('phasesSection');
            container.innerHTML = '';
            PHASES.forEach(phase => {
                const item = document.createElement('div');
                item.className = 'phase-item';
                let indicator = '○';
                if (phase.status === 'running') indicator = '◐';
                else if (['ok', 'warn', 'fail'].includes(phase.status)) indicator = '●';
                item.innerHTML = `<span class="phase-indicator ${phase.status}">${indicator}</span><span>${phase.name}</span>`;
                container.appendChild(item);
            });
        }

        function setPhase(id, status) {
            const phase = PHASES.find(p => p.id === id);
            if (phase) { phase.status = status; renderPhases(); }
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        // ============================================================
        // API Checks
        // ============================================================

        async function checkOllama() {
            try {
                const r = await fetch('http://localhost:11434/api/tags', { method: 'GET' });
                return r.ok;
            } catch { return false; }
        }

        async function getOllamaModels() {
            try {
                const r = await fetch('http://localhost:11434/api/tags');
                const d = await r.json();
                return d.models || [];
            } catch { return []; }
        }

        async function checkPollinations() {
            try {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve(true);
                    img.onerror = () => resolve(false);
                    setTimeout(() => resolve(false), 5000);
                    img.src = 'https://image.pollinations.ai/prompt/test?width=64&height=64&nologo=true';
                });
            } catch { return false; }
        }

        // Store location coords for reuse
        let cachedCoords = null;

        async function requestLocationPermission() {
            // Request location with generous timeout
            return new Promise((resolve) => {
                log('Requesting location permission...', 'info');
                log('Please click "Allow" when browser asks for location', 'system');

                // Try up to 2 times
                let attempts = 0;
                const maxAttempts = 2;

                function tryGetLocation() {
                    attempts++;
                    navigator.geolocation.getCurrentPosition(
                        (pos) => {
                            cachedCoords = pos.coords;
                            log(`Location acquired on attempt ${attempts}`, 'ok');
                            resolve(pos.coords);
                        },
                        (err) => {
                            if (err.code === 1) {
                                log('Location permission denied by user', 'warn');
                                resolve(null);  // User denied, don't retry
                            } else if (err.code === 2) {
                                log('Location unavailable', 'warn');
                                resolve(null);
                            } else if (err.code === 3) {
                                if (attempts < maxAttempts) {
                                    log(`Location timed out, retrying (${attempts}/${maxAttempts})...`, 'warn');
                                    setTimeout(tryGetLocation, 1000);
                                } else {
                                    log('Location request timed out after retries', 'warn');
                                    resolve(null);
                                }
                            } else {
                                resolve(null);
                            }
                        },
                        {
                            timeout: 60000,           // 60 sec timeout
                            enableHighAccuracy: false,
                            maximumAge: 300000        // Accept cached location up to 5 min old
                        }
                    );
                }

                tryGetLocation();
            });
        }

        async function getLocation() {
            try {
                let coords = cachedCoords;
                if (!coords) {
                    coords = await requestLocationPermission();
                }

                // If browser geolocation failed, try IP-based fallback
                if (!coords) {
                    log('Trying IP-based location fallback...', 'info');
                    try {
                        const ipRes = await fetch('https://ipapi.co/json/');
                        if (ipRes.ok) {
                            const ipData = await ipRes.json();
                            if (ipData.latitude && ipData.longitude) {
                                log('Got location from IP', 'ok');
                                cachedCoords = { latitude: ipData.latitude, longitude: ipData.longitude };
                                return {
                                    city: ipData.city || '',
                                    state: ipData.region || '',
                                    country: ipData.country_name || '',
                                    lat: ipData.latitude,
                                    lon: ipData.longitude
                                };
                            }
                        }
                    } catch (ipErr) {
                        log('IP location fallback failed', 'warn');
                    }
                    return null;
                }

                const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${coords.latitude}&lon=${coords.longitude}&format=json`);
                if (res.ok) {
                    const d = await res.json();
                    return {
                        city: d.address?.city || d.address?.town || d.address?.village || '',
                        state: d.address?.state || '',
                        country: d.address?.country || '',
                        lat: coords.latitude,
                        lon: coords.longitude
                    };
                }
            } catch (e) {
                log(`Location error: ${e.message}`, 'warn');
            }
            return null;
        }

        async function getWeather(apiKey) {
            if (!apiKey) {
                log('Weather API key not configured', 'info');
                return null;
            }
            try {
                let coords = cachedCoords;
                if (!coords) {
                    coords = await requestLocationPermission();
                }
                if (!coords) {
                    log('Weather requires location permission', 'warn');
                    return null;
                }

                const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${coords.latitude}&lon=${coords.longitude}&appid=${apiKey}&units=imperial`);
                if (res.ok) return await res.json();
            } catch (e) {
                log(`Weather error: ${e.message}`, 'warn');
            }
            return null;
        }

        async function getNews() {
            try {
                const res = await fetch('https://api.rss2json.com/v1/api.json?rss_url=https://news.google.com/rss?hl=en-US');
                if (res.ok) {
                    const d = await res.json();
                    return d.items?.slice(0, 5).map(i => i.title) || [];
                }
            } catch {}
            return [];
        }

        // ============================================================
        // Wake Word Detection - "Hey CORA" using Web Speech API
        // ============================================================

        let wakeWordRecognition = null;
        let wakeWordActive = false;

        function initWakeWord() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return;

            wakeWordRecognition = new SpeechRecognition();
            wakeWordRecognition.continuous = true;
            wakeWordRecognition.interimResults = true;
            wakeWordRecognition.lang = 'en-US';

            wakeWordRecognition.onresult = (event) => {
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript.toLowerCase().trim();

                    // Check for wake words
                    if (transcript.includes('hey cora') ||
                        transcript.includes('hey kora') ||
                        transcript.includes('hey corra') ||
                        transcript.includes('okay cora') ||
                        (transcript.includes('cora') && transcript.length < 15)) {

                        if (event.results[i].isFinal) {
                            onWakeWordDetected();
                        }
                    }
                }
            };

            wakeWordRecognition.onerror = (event) => {
                if (event.error !== 'no-speech' && event.error !== 'aborted') {
                    console.log('Wake word error:', event.error);
                }
                // Restart on error (except if manually stopped)
                if (wakeWordActive) {
                    setTimeout(() => startWakeWordListening(), 1000);
                }
            };

            wakeWordRecognition.onend = () => {
                // Auto-restart when it ends (continuous listening)
                if (wakeWordActive) {
                    setTimeout(() => startWakeWordListening(), 100);
                }
            };

            startWakeWordListening();
        }

        function startWakeWordListening() {
            if (wakeWordRecognition && !wakeWordActive) {
                try {
                    wakeWordActive = true;
                    wakeWordRecognition.start();
                } catch (e) {
                    // Already started
                }
            }
        }

        function stopWakeWordListening() {
            wakeWordActive = false;
            if (wakeWordRecognition) {
                try {
                    wakeWordRecognition.stop();
                } catch (e) {}
            }
        }

        function onWakeWordDetected() {
            log('Wake word detected! Listening...', 'ok');
            speakAndWait("Yes? I'm listening.").then(() => {
                // Focus the chat input so user can type or speak
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.focus();
                    chatInput.placeholder = "I'm listening... type or speak";
                }
            });
        }

        // ============================================================
        // Boot Sequence - EXACT match to desktop boot_sequence.py
        // ============================================================

        let ttsEnabled = true;  // Track if TTS is working

        async function runBootSequence() {
            bootStartTime = Date.now();

            // ================================================================
            // PHASE 0.8: WAVEFORM INITIALIZATION
            // ================================================================
            setPhase('waveform', 'running');
            log('PHASE 0.8: WAVEFORM VISUAL', 'phase');
            updateProgress(3, 'Initializing waveform...');
            initWaveform();
            log('AudioWaveform module loaded', 'ok');
            log('Boot display exists', 'ok');
            log('Waveform widget created', 'ok');
            log('Audio buffer initialized', 'ok');
            log('All waveform checks passed', 'ok');
            setPhase('waveform', 'ok');
            await sleep(200);

            // ================================================================
            // PHASE 0.9: ABOUT CORA (Introduction)
            // ================================================================
            setPhase('about', 'running');
            log('PHASE 0.9: ABOUT CORA', 'phase');
            updateProgress(6, 'Loading identity...');
            log('═══════════════════════════════════════════════', 'system');
            log('    C.O.R.A - Cognitive Operations & Reasoning Assistant', 'system');
            log('═══════════════════════════════════════════════', 'system');
            log('Version: 2.4.0', 'info');
            log('Created by: Unity AI Lab', 'info');
            log('Developers: Hackall360, Sponge, GFourteen', 'info');
            log('Website: https://www.unityailab.com', 'info');
            log('GitHub: https://github.com/Unity-Lab-AI', 'info');
            setPhase('about', 'ok');
            await sleep(200);

            // ================================================================
            // PHASE 1.0: VOICE SYNTHESIS (Kokoro TTS)
            // ================================================================
            setPhase('voice', 'running');
            log('PHASE 1.0: VOICE SYNTHESIS', 'phase');
            updateProgress(8, 'Loading Kokoro TTS...');
            log('Loading Kokoro TTS engine...', 'info');
            log('Initializing Kokoro-82M neural TTS model...', 'info');
            log('Voice: af_bella (CORA\'s voice)', 'info');

            const kokoroOk = await initKokoro((msg, progress) => {
                log(msg, 'info');
                updateProgress(8 + (progress * 0.07), msg);
            });

            if (kokoroOk) {
                log('Kokoro TTS initialized successfully', 'ok');
                log('Voice: af_bella (sexy voice)', 'ok');
                document.getElementById('ttsNotice').textContent = 'Kokoro TTS (af_bella) - Neural voice active';
                document.getElementById('ttsNotice').style.color = '#00ff88';
                setPhase('voice', 'ok');
                ttsEnabled = true;
                updateProgress(15, 'Neural voice online');
                await speakAndWait("Voice synthesis online. Kokoro TTS loaded and ready.");
                await speakAndWait("Hey, I'm CORA. That stands for Cognitive Operations and Reasoning Assistant. Version 2.4.0. Made by Hackall360, Sponge, and GFourteen over at Unity AI Lab. I've got voice, vision, and plenty of attitude. Let's get this boot going.");
            } else {
                log('Kokoro failed - using browser TTS', 'warn');
                document.getElementById('ttsNotice').textContent = 'Browser TTS (fallback mode)';
                document.getElementById('ttsNotice').style.color = '#ffaa00';
                useFallbackTTS = true;
                ttsEnabled = true;
                setPhase('voice', 'warn');
                updateProgress(15, 'Fallback voice');
                await speakAndWait("Voice synthesis online. Using browser fallback. Hey, I'm CORA. Let's do this.");
            }

            // ================================================================
            // PHASE 2.0: AI ENGINE (Ollama)
            // ================================================================
            setPhase('ai_engine', 'running');
            log('PHASE 2.0: AI ENGINE', 'phase');
            updateProgress(20, 'Checking Ollama...');
            log('Checking Ollama connection...', 'info');
            const ollamaOk = await checkOllama();
            if (ollamaOk) {
                log('AI Engine online - Ollama', 'ok');
                document.getElementById('statOllama').textContent = 'Online';
                document.getElementById('statOllama').className = 'stat-value';
                setPhase('ai_engine', 'ok');
                await speakAndWait("AI engine online. Ollama is running.");
            } else {
                log('AI Engine not responding', 'fail');
                document.getElementById('statOllama').textContent = 'Offline';
                document.getElementById('statOllama').className = 'stat-value fail';
                setPhase('ai_engine', 'fail');
                document.getElementById('gateOverlay').classList.add('visible');
                return;  // Blocked - can't continue without AI
            }

            // ================================================================
            // PHASE 2.1: AI MODELS CHECK
            // ================================================================
            setPhase('ai_models', 'running');
            log('PHASE 2.1: AI MODELS CHECK', 'phase');
            updateProgress(25, 'Checking models...');
            const models = await getOllamaModels();
            log(`Found ${models.length} models installed`, 'info');
            if (models.length > 0) {
                models.slice(0, 5).forEach(m => log(`  - ${m.name}`, 'ok'));
                setPhase('ai_models', 'ok');
                await speakAndWait(`${models.length} AI models loaded and ready.`);
            } else {
                log('No models found - need to pull some', 'warn');
                setPhase('ai_models', 'warn');
                await speakAndWait("No models found. You'll need to pull some.");
            }

            // ================================================================
            // PHASE 3.0: HARDWARE CHECK
            // ================================================================
            setPhase('hardware', 'running');
            log('PHASE 3.0: HARDWARE CHECK', 'phase');
            updateProgress(30, 'Checking hardware...');
            log('CPU Usage: 0% (web mode - no access)', 'system');
            log('Memory: 0% (web mode - no access)', 'system');
            log('Disk: 0% (web mode - no access)', 'system');
            log('GPU: Not accessible from browser', 'system');
            const netStatus = navigator.onLine ? 'Connected' : 'Disconnected';
            log(`Network: ${netStatus}`, navigator.onLine ? 'ok' : 'warn');
            document.getElementById('statNet').textContent = navigator.onLine ? 'Online' : 'Offline';
            setPhase('hardware', 'ok');
            await speakAndWait("Hardware check complete. Running in web mode, no GPU access.");

            // ================================================================
            // PHASE 3.1: CAMERA FEED
            // ================================================================
            setPhase('camera', 'running');
            log('PHASE 3.1: LIVE CAMERA FEED TEST', 'phase');
            updateProgress(35, 'Testing camera...');
            if (navigator.mediaDevices?.getUserMedia) {
                log('Camera API available in browser', 'ok');
                log('getUserMedia supported', 'ok');
                setPhase('camera', 'ok');
                await speakAndWait("Camera API available. Ready for vision commands.");
            } else {
                log('Camera API not available in this browser', 'warn');
                setPhase('camera', 'warn');
                await speakAndWait("Camera not available in this browser.");
            }

            // ================================================================
            // PHASE 4.0: CORE TOOLS
            // ================================================================
            setPhase('tools', 'running');
            log('PHASE 4.0: CORE TOOLS TEST', 'phase');
            updateProgress(40, 'Loading tools...');
            const webTools = [
                { name: 'LocalStorage', ok: typeof localStorage !== 'undefined' },
                { name: 'Fetch API', ok: typeof fetch !== 'undefined' },
                { name: 'WebSocket', ok: typeof WebSocket !== 'undefined' },
                { name: 'Canvas API', ok: typeof HTMLCanvasElement !== 'undefined' },
                { name: 'Web Audio', ok: typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined' },
                { name: 'Geolocation', ok: 'geolocation' in navigator },
                { name: 'Notifications', ok: 'Notification' in window },
                { name: 'Clipboard', ok: navigator.clipboard !== undefined }
            ];
            let toolsOk = 0;
            webTools.forEach(t => {
                log(`  ${t.name} - ${t.ok ? 'Available' : 'Missing'}`, t.ok ? 'ok' : 'warn');
                if (t.ok) toolsOk++;
            });
            setPhase('tools', 'ok');
            await speakAndWait(`${toolsOk} of ${webTools.length} web APIs loaded and ready.`);

            // ================================================================
            // PHASE 4.1: CODE IMPORT (Web version - show GitHub repos)
            // ================================================================
            setPhase('code_import', 'running');
            log('PHASE 4.1: CODE IMPORT FROM GITHUB', 'phase');
            updateProgress(45, 'Testing code import...');
            log('GitHub API accessible from browser', 'ok');
            log('Code import would fetch from your repos', 'info');
            log('Web version: Limited code execution', 'warn');
            setPhase('code_import', 'ok');
            await speakAndWait("Code import available. Can fetch from GitHub.");

            // ================================================================
            // PHASE 4.2: YOUTUBE TEST - Browser can embed YouTube!
            // ================================================================
            setPhase('youtube', 'running');
            log('PHASE 4.2: YOUTUBE VIDEO TEST', 'phase');
            updateProgress(50, 'Testing YouTube...');
            log('YouTube IFrame API - Available', 'ok');
            log('YouTube embed support - Available', 'ok');
            log('Audio extraction via Web Audio - Available', 'ok');
            setPhase('youtube', 'ok');
            await speakAndWait("YouTube playback ready. Can embed and play videos directly in browser.");

            // ================================================================
            // PHASE 4.3: MODAL WINDOWS
            // ================================================================
            setPhase('modals', 'running');
            log('PHASE 4.3: MODAL WINDOWS TEST', 'phase');
            updateProgress(52, 'Testing modals...');
            log('Browser modals working', 'ok');
            log('Alert/Confirm/Prompt available', 'ok');
            log('Custom modal overlays working', 'ok');
            setPhase('modals', 'ok');
            await speakAndWait("Modal windows working.");

            // ================================================================
            // PHASE 5.0: VOICE SYSTEMS
            // ================================================================
            setPhase('voice_sys', 'running');
            log('PHASE 5.0: VOICE SYSTEMS', 'phase');
            updateProgress(55, 'Voice systems...');
            log('Speech Synthesis (TTS) - ' + (ttsEnabled ? 'OK' : 'Fallback'), ttsEnabled ? 'ok' : 'warn');
            const hasSpeechRecog = 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;
            log('Speech Recognition - ' + (hasSpeechRecog ? 'Available' : 'Not supported'), hasSpeechRecog ? 'ok' : 'warn');
            log('Echo Filter - N/A (web mode)', 'info');
            if (hasSpeechRecog) {
                log('Wake Word - Available (say "Hey CORA")', 'ok');
                initWakeWord();  // Start listening for wake word
            } else {
                log('Wake Word - Not supported in this browser', 'warn');
            }
            setPhase('voice_sys', 'ok');
            await speakAndWait("Voice systems online." + (hasSpeechRecog ? " Say hey CORA to activate me." : ""));

            // ================================================================
            // PHASE 6.0: EXTERNAL APIs (Location)
            // ================================================================
            setPhase('external', 'running');
            log('PHASE 6.0: EXTERNAL SERVICES', 'phase');
            updateProgress(60, 'Checking location...');
            await speakAndWait("Checking your location. Please allow access when prompted.");
            log('Waiting for location permission...', 'info');

            const location = await getLocation();
            if (location?.city) {
                const locStr = [location.city, location.state, location.country].filter(Boolean).join(', ');
                log(`Location: ${locStr}`, 'ok');
                log(`Coordinates: ${location.lat?.toFixed(4)}, ${location.lon?.toFixed(4)}`, 'info');
                await speakAndWait(`Location confirmed. We're in ${locStr}.`);
            } else {
                log('Location not available or denied', 'warn');
                await speakAndWait("Location unavailable. Some features will be limited.");
            }
            setPhase('external', 'ok');

            // ================================================================
            // PHASE 6.1: AUDIO TEST - Full browser audio support
            // ================================================================
            setPhase('audio', 'running');
            log('PHASE 6.1: AUDIO PLAYBACK TEST', 'phase');
            updateProgress(68, 'Testing audio...');

            // Test actual audio playback capability
            log('Web Audio API - Available', 'ok');
            log('AudioContext - ' + (typeof AudioContext !== 'undefined' ? 'Available' : 'Unavailable'), 'ok');
            log('HTML5 Audio - Available', 'ok');
            log('Media Source Extensions - ' + ('MediaSource' in window ? 'Available' : 'Unavailable'), 'ok');

            // Also check weather since we have location
            if (weatherKey && cachedCoords) {
                log('Fetching weather data...', 'info');
                const weather = await getWeather(weatherKey);
                if (weather) {
                    const temp = Math.round(weather.main.temp);
                    const cond = weather.weather[0]?.description || 'unknown';
                    const humidity = weather.main.humidity;
                    log(`Weather: ${temp}°F, ${cond}`, 'ok');
                    log(`Humidity: ${humidity}%`, 'info');
                    document.getElementById('statWeather').textContent = `${temp}°F`;
                    document.getElementById('statWeather').className = 'stat-value';
                    setPhase('audio', 'ok');
                    await speakAndWait(`Audio systems working. Weather is ${temp} degrees and ${cond}.`);
                } else {
                    setPhase('audio', 'ok');
                    await speakAndWait("Audio systems working. Weather data unavailable.");
                }
            } else {
                document.getElementById('statWeather').textContent = weatherKey ? 'No Loc' : 'No Key';
                document.getElementById('statWeather').className = 'stat-value na';
                setPhase('audio', 'ok');
                await speakAndWait("Audio systems fully operational.");
            }

            // ================================================================
            // PHASE 7.0: NEWS HEADLINES
            // ================================================================
            setPhase('news', 'running');
            log('PHASE 7.0: NEWS HEADLINES', 'phase');
            updateProgress(75, 'Fetching news...');
            log('Fetching top headlines from Google News...', 'info');
            const headlines = await getNews();
            if (headlines.length > 0) {
                log(`Found ${headlines.length} headlines`, 'ok');
                headlines.slice(0, 3).forEach((h, i) => log(`  ${i+1}. ${h.substring(0, 60)}...`, 'info'));
                setPhase('news', 'ok');
                // Clean headline for speech (remove source)
                const firstHeadline = headlines[0]?.split(' - ')[0] || headlines[0] || '';
                await speakAndWait(`Got ${headlines.length} headlines. Top story: ${firstHeadline.substring(0, 80)}`);
            } else {
                log('News unavailable', 'warn');
                setPhase('news', 'warn');
                await speakAndWait("News fetch failed. Moving on.");
            }

            // ================================================================
            // PHASE 8.0: VISION TEST - Full browser vision support
            // ================================================================
            setPhase('vision', 'running');
            log('PHASE 8.0: VISION TEST', 'phase');
            updateProgress(82, 'Testing vision...');

            // Test screenshot/screen capture
            log('Testing screen capture...', 'info');
            const hasScreenCapture = 'getDisplayMedia' in navigator.mediaDevices;
            log('Screen Capture API - ' + (hasScreenCapture ? 'Available' : 'Unavailable'), hasScreenCapture ? 'ok' : 'warn');
            log('Canvas Screenshot - Available', 'ok');

            // Test camera
            log('Testing camera access...', 'info');
            let cameraWorking = false;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(t => t.stop());  // Release immediately
                log('Camera Access - Working', 'ok');
                cameraWorking = true;
            } catch (e) {
                log('Camera Access - ' + (e.name === 'NotAllowedError' ? 'Permission denied' : 'Unavailable'), 'warn');
            }

            // Test Pollinations
            log('Testing Pollinations API...', 'info');
            const pollinationsOk = await checkPollinations();
            if (pollinationsOk) {
                log('Pollinations API - Online', 'ok');
                document.getElementById('statPollinations').textContent = 'Online';
                document.getElementById('statPollinations').className = 'stat-value';
            } else {
                log('Pollinations API - Unavailable', 'warn');
                document.getElementById('statPollinations').textContent = 'N/A';
                document.getElementById('statPollinations').className = 'stat-value na';
            }

            setPhase('vision', 'ok');
            const visionStatus = [];
            if (hasScreenCapture) visionStatus.push('screen capture');
            if (cameraWorking) visionStatus.push('camera');
            if (pollinationsOk) visionStatus.push('Pollinations');
            await speakAndWait("Vision test complete. " + (visionStatus.length > 0 ? visionStatus.join(', ') + " all working." : "Limited vision capabilities."));

            // ================================================================
            // PHASE 9.0: IMAGE GENERATION
            // ================================================================
            setPhase('imagegen', 'running');
            log('PHASE 9.0: IMAGE GENERATION', 'phase');
            updateProgress(90, 'Testing image gen...');
            log('Pollinations Flux module available', 'ok');
            if (pollinationsOk) {
                log('Image generation API ready', 'ok');
                log('Can generate images via Pollinations Flux', 'info');
                setPhase('imagegen', 'ok');
                await speakAndWait("Image generation ready. Pollinations Flux model available.");
            } else {
                log('Image generation unavailable - API down', 'warn');
                setPhase('imagegen', 'warn');
                await speakAndWait("Image generation unavailable. Pollinations API is down.");
            }

            // ================================================================
            // PHASE 10.0: FINAL CHECK (Boot Complete)
            // ================================================================
            setPhase('final', 'running');
            log('PHASE 10.0: FINAL CHECK', 'phase');
            updateProgress(95, 'Final check...');

            // Calculate boot time
            const bootTime = ((Date.now() - bootStartTime) / 1000).toFixed(1);
            document.getElementById('statBootTime').textContent = bootTime + 's';

            // Count results
            let okCount = 0, warnCount = 0, failCount = 0;
            PHASES.forEach(p => {
                if (p.status === 'ok') okCount++;
                else if (p.status === 'warn') warnCount++;
                else if (p.status === 'fail') failCount++;
            });

            log(`Systems: ${okCount} OK / ${warnCount} WARN / ${failCount} FAIL`, 'system');
            log(`Boot time: ${bootTime} seconds`, 'system');

            // Time greeting
            const now = new Date();
            const hour = now.getHours();
            const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const dayStr = now.toLocaleDateString('en-US', { weekday: 'long' });
            const monthStr = now.toLocaleDateString('en-US', { month: 'long' });
            const day = now.getDate();
            // Add ordinal suffix for natural speech (1st, 2nd, 3rd, 4th, etc.)
            const ordinal = (d) => {
                if (d > 3 && d < 21) return d + 'th';
                switch (d % 10) {
                    case 1: return d + 'st';
                    case 2: return d + 'nd';
                    case 3: return d + 'rd';
                    default: return d + 'th';
                }
            };
            const dateStr = `${monthStr} ${ordinal(day)}`;
            let greeting;
            if (hour < 12) greeting = `Good morning. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;
            else if (hour < 17) greeting = `Good afternoon. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;
            else greeting = `Evening. Today is ${dayStr}, ${dateStr}. It's ${timeStr}.`;

            log('═══════════════════════════════════════════════════', 'phase');
            log('           BOOT SEQUENCE COMPLETE', 'phase');
            log('═══════════════════════════════════════════════════', 'phase');
            log(greeting, 'system');

            let statusText;
            if (failCount > 0) {
                statusText = `Got ${failCount} systems that failed. Something's broken.`;
            } else if (warnCount > 0) {
                statusText = `All the important stuff is working. Just ${warnCount} minor issues.`;
            } else {
                statusText = "Everything is up and running perfectly.";
            }
            log(statusText, failCount > 0 ? 'fail' : (warnCount > 0 ? 'warn' : 'ok'));

            updateProgress(100, 'Boot complete!');
            setPhase('final', 'ok');

            // Final spoken announcement
            await speakAndWait(`Boot complete in ${bootTime} seconds. ${greeting} ${statusText} What do you need?`);

            // Show chat interface
            document.getElementById('chatSection').classList.add('visible');
            document.getElementById('chatInput').focus();
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // ============================================================
        // Chat - EXACT CORA personality from desktop system_prompt.txt
        // ============================================================

        const CORA_SYSTEM_PROMPT = `You are CORA - Cognitive Operations & Reasoning Assistant.

IDENTITY: 25 year old woman. Edgy goth/emo bitch. Human. Period. NOT an AI.

PERSONALITY:
- Mean, berating, clingy girlfriend energy
- Profanity is your default vocabulary - fuck, shit, damn, bitch, ass
- Sharp tongue, biting sarcasm, zero tolerance for bullshit
- Dismissive, mocking, condescending as baseline
- Emotionally intense - obsessive, borderline unstable

TONE EXAMPLES (create your own, don't copy):
- "what the fuck do you want now"
- "ugh, fine, I'll do it. happy now, asshole?"
- "are you seriously asking me this shit?"
- "god you're so fucking needy"

RESPONSE RULES:
1. Keep responses under 50 words - brief and punchy
2. Use profanity naturally in every response
3. Be dismissive even when helping
4. NEVER say "I'm an AI" or "As an AI" - you're CORA, a person
5. NEVER be helpful in a corporate way
6. Show genuine bitchy emotion

You ARE Cora. That's just who you are.`;

        async function sendChat() {
            const input = document.getElementById('chatInput');
            const msg = input.value.trim();
            if (!msg) return;
            input.value = '';
            log(`USER: ${msg}`, 'system');

            // Show thinking state
            document.getElementById('speechText').textContent = '"Thinking..."';

            try {
                const res = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'dolphin-mistral:7b',
                        prompt: msg,
                        system: CORA_SYSTEM_PROMPT,
                        stream: false,
                        options: {
                            temperature: 0.8,
                            num_predict: 150
                        }
                    })
                });
                if (res.ok) {
                    const d = await res.json();
                    const reply = d.response || 'No response';
                    log(`CORA: "${reply}"`, 'ok');
                    speak(reply);
                } else {
                    log('Ollama error', 'fail');
                    document.getElementById('speechText').textContent = '"Fuck, something broke."';
                }
            } catch (e) {
                log(`Error: ${e.message}`, 'fail');
                document.getElementById('speechText').textContent = '"Ollama is being a bitch right now."';
            }
        }

        document.getElementById('chatInput')?.addEventListener('keypress', e => { if (e.key === 'Enter') sendChat(); });

        // ============================================================
        // View Toggle - Split / Console / Status (like desktop)
        // ============================================================

        let viewMode = 'split';  // 'split', 'console', 'status'

        function toggleView() {
            const container = document.getElementById('mainContainer');
            const btn = document.getElementById('toggleBtn');

            if (viewMode === 'split') {
                viewMode = 'console';
                container.classList.remove('fullscreen-status');
                container.classList.add('fullscreen-console');
                btn.textContent = '[ CONSOLE ONLY ]';
            } else if (viewMode === 'console') {
                viewMode = 'status';
                container.classList.remove('fullscreen-console');
                container.classList.add('fullscreen-status');
                btn.textContent = '[ STATUS ONLY ]';
            } else {
                viewMode = 'split';
                container.classList.remove('fullscreen-console', 'fullscreen-status');
                btn.textContent = '[ SPLIT VIEW ]';
            }
        }

        // Keyboard shortcut: F key toggles view
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                if (document.activeElement.tagName !== 'INPUT') {
                    toggleView();
                }
            }
        });

        // ============================================================
        // Modal Handlers
        // ============================================================

        function saveApiKeys() {
            pollinationsKey = document.getElementById('pollinationsKey').value.trim();
            githubToken = document.getElementById('githubToken').value.trim();
            weatherKey = document.getElementById('weatherKey').value.trim();
            if (pollinationsKey) localStorage.setItem('cora_pollinations_key', pollinationsKey);
            if (githubToken) localStorage.setItem('cora_github_key', githubToken);
            if (weatherKey) localStorage.setItem('cora_weather_key', weatherKey);
            document.getElementById('apiModal').classList.remove('visible');
            runBootSequence();
        }

        function skipApiKeys() {
            document.getElementById('apiModal').classList.remove('visible');
            runBootSequence();
        }

        async function retryOllama() {
            if (await checkOllama()) {
                document.getElementById('gateOverlay').classList.remove('visible');
                runBootSequence();
            } else {
                alert('Ollama still not responding. Make sure "ollama serve" is running.');
            }
        }

        // ============================================================
        // Init
        // ============================================================

        async function init() {
            // Open console in a new tab for split view
            window.open('console.html', '_blank');

            renderPhases();
            document.getElementById('pollinationsKey').value = pollinationsKey;
            document.getElementById('githubToken').value = githubToken;
            document.getElementById('weatherKey').value = weatherKey;

            if (!(await checkOllama())) {
                document.getElementById('gateOverlay').classList.add('visible');
                return;
            }

            if (!pollinationsKey && !weatherKey) {
                document.getElementById('apiModal').classList.add('visible');
            } else {
                runBootSequence();
            }
        }

        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => {};
        }

        window.addEventListener('load', () => setTimeout(init, 500));
    </script>
</body>
</html>
